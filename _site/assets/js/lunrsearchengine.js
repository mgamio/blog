
var documents = [{
    "id": 0,
    "url": "http://localhost:4000/404.html",
    "title": "",
    "body": " 404 Page not found :(  The requested page could not be found. "
    }, {
    "id": 1,
    "url": "http://localhost:4000/about",
    "title": "About me",
    "body": "    I was born in Lima, Peru, where I studied for 5 years and obtained a degree in System Engineering. I have been working 20 years as a Software Engineer for several companies from different economic sectors such as Government, Financial, Industrial, Educative, Consulting, Retail, and Research.      A little more. . . :   I have been programming in several languages such as Java, C, Cobol, C#, Visual Basic, PHP, Prolog, Python, PL/SQL and JScript. My tasks have been related to Software Development, stages of Analysis, Design, Testing, and Deployment.   During 8 years, I worked as a System Analyst for the Bank Sector. Since 2014, I am working as a Software Engineer in a B2B company in Berlin, Germany.   This is my blog site to share my knowledge and experience. At the moment, I am passionate about the following things:      Clean Code   Spring Framework   Web APIs   Automated testing   Software Design   Software Architecture   Distributed Systems   Data Structure and Algorithms   Learning new technologies  	       	 Buy me a coffee   Thank you for your support! Your donation helps me to maintain and improve codersite.                      	 A fun t-shirt for every front-end, backend or developers who loves programming.       	 I want this!    Follow me on: "
    }, {
    "id": 2,
    "url": "http://localhost:4000/affiliate",
    "title": "Boost your knowledge with these great books",
    "body": "  																			Threads are a fundamental part of the Java platform. As multicore processors become the norm, using concurrency effectively becomes essential for building high-performance applications: 													Learn more				    																			The Big Ideas Behind Reliable, Scalable, and Maintainable Systems. Data is at the center of many challenges in system design today. : 													Learn more				    																						By using concrete examples, minimal theory, and two production-ready Python frameworks—Scikit-Learn and TensorFlow—this book helps you gain an intuitive understanding of the concepts and tools for building intelligent systems. : 													Learn more				    																			Aspiring and existing architects alike will examine architectural characteristics, architectural patterns, component determination, diagramming and presenting architecture, evolutionary architecture, and many other topics. : 													Learn more				    						  Disclosure: I’m a proud affiliate of some of the resources mentioned in this article. If you buy a book through my links on this page, I may get a small commission for referring you. Thanks! "
    }, {
    "id": 3,
    "url": "http://localhost:4000/categories",
    "title": "Categories",
    "body": ""
    }, {
    "id": 4,
    "url": "http://localhost:4000/impressum",
    "title": "Impressum",
    "body": "            Impressum      codersite is run by Moises Gamio 						Address: Romain-rolland Str 13089 Berlin, Germany 			Email: codersitedev@gmail. com 			Tax number: 32/300/01607       	          Content policy:       The content published on this website is original, clear, concise, and examples are based on the author's personal experience. 			Whenever necessary, I refer links to the sources for more in-depth information. 			I usually improve the contents based on users feedback 			      	          Advertising policy:       I use affiliate links. When you click on those links and buy something, I earn a commission. In that way, you help me to support this website. 			      "
    }, {
    "id": 5,
    "url": "http://localhost:4000/",
    "title": "Home",
    "body": "      Featured:                                                                                                                                                   							                                                                                                                    Big O Notation: Analysis of Algorithms - coding interview                              :               Big O Notation is a mathematical notation that helps us analyze how complex an algorithm is in terms of time and space. When we build. . . :                                                                                                                                                                       Moises Gamio                                22 Jun 2020                                                                                                                                                                                              							                                                                                                                    SOLID principles: The Definitive Guide (Part I)                              :               SOLID principles tell you how to arrange your functions into classes and how those classes should be interrelated. :                                                                                                                                                                       Moises Gamio                                15 Jun 2020                                                                                                                                              All Stories:                                                                                                     Understanding Object-Oriented Programming concepts              :       Object-oriented concepts give you a solid foundation for making critical design decisions. :                                                                               Moises Gamio                20 May 2022                                                                                                                                     SSL Handshake Failure              :       The Secure Socket Layer (SSL) enables a secured connection between a client and a server. SSL Handshake is a set of steps that make it possible for this secured connection. . . :                                                                               Moises Gamio                11 May 2022                                                                                                                                     Spring Boot, OpenAPI3, and OAuth2              :       This tutorial will show how to integrate OAuth2 with Spring Security in a Spring Boot application with OpenAPI 3. :                                                                               Moises Gamio                26 Apr 2022                                                                                                                                     UML Diagrams for Java Developers              :       The Unified Modeling Language is a graphical notation for modeling systems and conveying User software requirements. All developers must understand this notation before starting programming. :                                                                               Moises Gamio                09 Mar 2022                                                                                                                                     SOLID principles: The Open-Closed Principle (Part II)              :       SOLID principles tell you how to arrange your functions into classes and how those classes should be interrelated. :                                                                               Moises Gamio                06 Jan 2022                                                                                                                                     Shopping options              :       An Amazon customer wants to buy a pair of jeans, a pair of shoes, a skirt, and a top but has a limited budget in dollars. Given different pricing options. . . :                                                                               Moises Gamio                28 Dec 2021                                               &laquo; Prev       1        2        3      Next &raquo; "
    }, {
    "id": 6,
    "url": "http://localhost:4000/policy",
    "title": "Privacy policy",
    "body": "            Privacy policy      This policy describes the personal data that we collect, how we use and share it, your rights and choices. 			If you have additional questions or require more information about our Privacy Policy, do not hesitate to contact us.       	          Consent:       By using our website, you hereby consent to our Privacy Policy and agree to its terms.       	          Information we collect:       If you contact us directly, we may receive additional information about you such as your name, email address, phone number, the contents of the message and/or attachments you may send us, and any other information you may choose to provide.       	          How we use your information:       We use the information we collect in various ways, including to: 							Improve, personalize, and expand our website				Understand and analyze how you use our website				Develop new services, features, and functionality				Communicate with you to provide you with updates and other information relating to the website, i. e. , new posts. 				Find and prevent fraud			      	          Log Files:       codersite. dev follows a standard procedure of using log files. These files log visitors when they visit websites. All hosting companies do this and a part of hosting services' analytics. The information collected by log files include internet protocol (IP) addresses, browser type, Internet Service Provider (ISP), date and time stamp, referring/exit pages, and possibly the number of clicks. These are not linked to any information that is personally identifiable. The purpose of the information is for analyzing trends, administering the site, tracking users' movement on the website, and gathering demographic information       	          Google DoubleClick DART Cookie:       Google is one of a third-party vendor on our site. It also uses cookies, known as DART cookies, to serve ads to our site visitors based upon their visit to www. website. com and other sites on the internet. However, visitors may choose to decline the use of DART cookies by visiting the Google ad and content network Privacy Policy at the following URL – https://policies. google. com/technologies/ads       	          Google Analytics:       This website also uses Google Analytics to analyse how and when you visit our website in order to be able to understand your needs and improve your experience on our website. By using our website, you agree that your information is used for these purposes however your information is kept anonymous unless you specifically agree otherwise. 			You can opt out of these features by downloading the following opt-out browser add-on: 			https://tools. google. com/dlpage/gaoptout 					Please check that your browser supports such an add-on.       	          Advertising Partners Privacy Policies:       You may consult this list to find the Privacy Policy for each of the advertising partners of codersite. dev. 			Third-party ad servers or ad networks uses technologies like cookies, JavaScript, or Web Beacons that are used in their respective advertisements and links that appear on codersite. dev, which are sent directly to users' browser. They automatically receive your IP address when this occurs. These technologies are used to measure the effectiveness of their advertising campaigns and/or to personalize the advertising content that you see on websites that you visit. 			Note that codersite. dev has no access to or control over these cookies that are used by third-party advertisers.       	          Third Party Privacy Policies:       codersite. dev's Privacy Policy does not apply to other advertisers or websites. Thus, we are advising you to consult the respective Privacy Policies of these third-party ad servers for more detailed information. It may include their practices and instructions about how to opt-out of certain options. 			You can choose to disable cookies through your individual browser options. To know more detailed information about cookie management with specific web browsers, it can be found at the browsers' respective websites.       	    			CCPA Privacy Rights (Do Not Sell My Personal Information): 			Under the CCPA, among other rights, California consumers have the right to: 			Request that a business that collects a consumer's personal data disclose the categories and specific pieces of personal data that a business has collected about consumers. 			Request that a business delete any personal data about the consumer that a business has collected. 			Request that a business that sells a consumer's personal data, not sell the consumer's personal data. 			If you make a request, we have one month to respond to you. If you would like to exercise any of these rights, please contact us.       	    			GDPR Data Protection Rights: 			We would like to make sure you are fully aware of all of your data protection rights. Every user is entitled to the following: 			The right to access – You have the right to request copies of your personal data. We may charge you a small fee for this service. 			The right to rectification – You have the right to request that we correct any information you believe is inaccurate. You also have the right to request that we complete the information you believe is incomplete. 			The right to erasure – You have the right to request that we erase your personal data, under certain conditions. 			The right to restrict processing – You have the right to request that we restrict the processing of your personal data, under certain conditions. 			The right to object to processing – You have the right to object to our processing of your personal data, under certain conditions. 			The right to data portability – You have the right to request that we transfer the data that we have collected to another organization, or directly to you, under certain conditions. 			If you make a request, we have one month to respond to you. If you would like to exercise any of these rights, please contact us.       	    			Children's Information: 			Another part of our priority is adding protection for children while using the internet. We encourage parents and guardians to observe, participate in, and/or monitor and guide their online activity. 			codersite. dev does not knowingly collect any Personal Identifiable Information from children under the age of 13. If you think that your child provided this kind of information on our website, we strongly encourage you to contact us immediately and we will do our best efforts to promptly remove such information from our records.       "
    }, {
    "id": 7,
    "url": "http://localhost:4000/termsOfService",
    "title": "Terms and Conditions",
    "body": "            Terms and Conditions      			Last updated: January 17, 2022 			Please read these terms and conditions carefully before using Our Service. 			Interpretation and Definitions: 			Interpretation: 			The words of which the initial letter is capitalized have meanings defined under the following conditions. The following definitions shall have the same meaning regardless of whether they appear in singular or in plural. 			Definitions: 			For the purposes of these Terms and Conditions: 									Affiliate means an entity that controls, is controlled by or is under common control with a party, where &quot;control&quot; means ownership of 50% or more of the shares, equity interest or other securities entitled to vote for election of directors or other managing authority. 									Country refers to: Berlin, Germany 									Company (referred to as either &quot;the Company&quot;, &quot;We&quot;, &quot;Us&quot; or &quot;Our&quot; in this Agreement) refers to codersite. 									Device means any device that can access the Service such as a computer, a cellphone or a digital tablet. 									Service refers to the Website. 									Terms and Conditions (also referred as &quot;Terms&quot;) mean these Terms and Conditions that form the entire agreement between You and the Company regarding the use of the Service. This Terms and Conditions agreement has been created with the help of the Terms and Conditions Template. 									Third-party Social Media Service means any services or content (including data, information, products or services) provided by a third-party that may be displayed, included or made available by the Service. 									Website refers to codersite, accessible from https://codersite. dev 									You means the individual accessing or using the Service, or the company, or other legal entity on behalf of which such individual is accessing or using the Service, as applicable. 									Acknowledgment: 			These are the Terms and Conditions governing the use of this Service and the agreement that operates between You and the Company. These Terms and Conditions set out the rights and obligations of all users regarding the use of the Service. 			Your access to and use of the Service is conditioned on Your acceptance of and compliance with these Terms and Conditions. These Terms and Conditions apply to all visitors, users and others who access or use the Service. 			By accessing or using the Service You agree to be bound by these Terms and Conditions. If You disagree with any part of these Terms and Conditions then You may not access the Service. 			You represent that you are over the age of 18. The Company does not permit those under 18 to use the Service. 			Your access to and use of the Service is also conditioned on Your acceptance of and compliance with the Privacy Policy of the Company. Our Privacy Policy describes Our policies and procedures on the collection, use and disclosure of Your personal information when You use the Application or the Website and tells You about Your privacy rights and how the law protects You. Please read Our Privacy Policy carefully before using Our Service. 			Links to Other Websites: 			Our Service may contain links to third-party web sites or services that are not owned or controlled by the Company. 			The Company has no control over, and assumes no responsibility for, the content, privacy policies, or practices of any third party web sites or services. You further acknowledge and agree that the Company shall not be responsible or liable, directly or indirectly, for any damage or loss caused or alleged to be caused by or in connection with the use of or reliance on any such content, goods or services available on or through any such web sites or services. 			We strongly advise You to read the terms and conditions and privacy policies of any third-party web sites or services that You visit. 			Termination: 			We may terminate or suspend Your access immediately, without prior notice or liability, for any reason whatsoever, including without limitation if You breach these Terms and Conditions. 			Upon termination, Your right to use the Service will cease immediately. 			Limitation of Liability: 			Notwithstanding any damages that You might incur, the entire liability of the Company and any of its suppliers under any provision of this Terms and Your exclusive remedy for all of the foregoing shall be limited to the amount actually paid by You through the Service or 100 USD if You haven't purchased anything through the Service. 			To the maximum extent permitted by applicable law, in no event shall the Company or its suppliers be liable for any special, incidental, indirect, or consequential damages whatsoever (including, but not limited to, damages for loss of profits, loss of data or other information, for business interruption, for personal injury, loss of privacy arising out of or in any way related to the use of or inability to use the Service, third-party software and/or third-party hardware used with the Service, or otherwise in connection with any provision of this Terms), even if the Company or any supplier has been advised of the possibility of such damages and even if the remedy fails of its essential purpose. 			Some states do not allow the exclusion of implied warranties or limitation of liability for incidental or consequential damages, which means that some of the above limitations may not apply. In these states, each party's liability will be limited to the greatest extent permitted by law. 			&quot;AS IS&quot; and &quot;AS AVAILABLE&quot; Disclaimer: 			The Service is provided to You &quot;AS IS&quot; and &quot;AS AVAILABLE&quot; and with all faults and defects without warranty of any kind. To the maximum extent permitted under applicable law, the Company, on its own behalf and on behalf of its Affiliates and its and their respective licensors and service providers, expressly disclaims all warranties, whether express, implied, statutory or otherwise, with respect to the Service, including all implied warranties of merchantability, fitness for a particular purpose, title and non-infringement, and warranties that may arise out of course of dealing, course of performance, usage or trade practice. Without limitation to the foregoing, the Company provides no warranty or undertaking, and makes no representation of any kind that the Service will meet Your requirements, achieve any intended results, be compatible or work with any other software, applications, systems or services, operate without interruption, meet any performance or reliability standards or be error free or that any errors or defects can or will be corrected. 			Without limiting the foregoing, neither the Company nor any of the company's provider makes any representation or warranty of any kind, express or implied: (i) as to the operation or availability of the Service, or the information, content, and materials or products included thereon; (ii) that the Service will be uninterrupted or error-free; (iii) as to the accuracy, reliability, or currency of any information or content provided through the Service; or (iv) that the Service, its servers, the content, or e-mails sent from or on behalf of the Company are free of viruses, scripts, trojan horses, worms, malware, timebombs or other harmful components. 			Some jurisdictions do not allow the exclusion of certain types of warranties or limitations on applicable statutory rights of a consumer, so some or all of the above exclusions and limitations may not apply to You. But in such a case the exclusions and limitations set forth in this section shall be applied to the greatest extent enforceable under applicable law. 			Governing Law: 			The laws of the Country, excluding its conflicts of law rules, shall govern this Terms and Your use of the Service. Your use of the Application may also be subject to other local, state, national, or international laws. 			Disputes Resolution: 			If You have any concern or dispute about the Service, You agree to first try to resolve the dispute informally by contacting the Company. 			For European Union (EU) Users: 			If You are a European Union consumer, you will benefit from any mandatory provisions of the law of the country in which you are resident in. 			United States Legal Compliance: 			You represent and warrant that (i) You are not located in a country that is subject to the United States government embargo, or that has been designated by the United States government as a &quot;terrorist supporting&quot; country, and (ii) You are not listed on any United States government list of prohibited or restricted parties. 			Severability and Waiver: 			Severability: 			If any provision of these Terms is held to be unenforceable or invalid, such provision will be changed and interpreted to accomplish the objectives of such provision to the greatest extent possible under applicable law and the remaining provisions will continue in full force and effect. 			Waiver: 			Except as provided herein, the failure to exercise a right or to require performance of an obligation under these Terms shall not effect a party's ability to exercise such right or require such performance at any time thereafter nor shall the waiver of a breach constitute a waiver of any subsequent breach. 			Translation Interpretation: 			These Terms and Conditions may have been translated if We have made them available to You on our Service. 			You agree that the original English text shall prevail in the case of a dispute. 			Changes to These Terms and Conditions: 			We reserve the right, at Our sole discretion, to modify or replace these Terms at any time. If a revision is material We will make reasonable efforts to provide at least 30 days' notice prior to any new terms taking effect. What constitutes a material change will be determined at Our sole discretion. 			By continuing to access or use Our Service after those revisions become effective, You agree to be bound by the revised terms. If You do not agree to the new terms, in whole or in part, please stop using the website and the Service. 			Contact Us: 			If you have any questions about these Terms and Conditions, You can contact us: 						By email: codersitedev@gmail. com				      	"
    }, {
    "id": 8,
    "url": "http://localhost:4000/page2/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:       {% for post in site. posts %}    {% if post. featured == true %}      {% include featuredbox. html %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 9,
    "url": "http://localhost:4000/page3/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:       {% for post in site. posts %}    {% if post. featured == true %}      {% include featuredbox. html %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 10,
    "url": "http://localhost:4000/robots.txt",
    "title": "",
    "body": "      Sitemap: {{ “sitemap. xml”   absolute_url }}   "
    }, {
    "id": 11,
    "url": "http://localhost:4000/understanding-oop-concepts/",
    "title": "Understanding Object-Oriented Programming concepts",
    "body": "2022/05/20 - Object-oriented concepts give you a solid foundation for making critical design decisions. Class: A class is a template or prototype that describes what an object will be. It defines its attributes(data) and behavior(methods). We must design a class before creating an object. Object: An object is an instance of a class. When we create an object, we create real-world entities such as auto, bicycles, or dogs with their own attributes and own behaviors.  In Java we instantiate an object via the new keyword. When you design a class follow the Single Resposibility Principle (SRP). Abstraction: Abstraction allows an object telling to its users what an application does instead of how it does it. You can see the essential buttons in your TV remote control, but you don’t care what happens behind when you press one of these buttons. In Java, we create abstractions via Interfaces and Abstract classes. Encapsulation and Data Hiding: Restricting access to specific attributes and methods is called data hiding. Objects should not manipulate the data of other objects. Encapsulation is the action to combine the data and methods in the same entity. In this way, we control access to the data in the object. Inheritance: Inheritance is a process in which a class inherits the attributes and methods of another class. Inheritance provides the ability to create new classes with new functionalities maintaining the functionalities inherited. In this way, it promotes code reusability. In Java, we create inheritance between classes via the extends keyword. Polymorphism: Polymorphism means many shapes and is coupled to inheritance. For example, a Shape class defines a draw method, but Square and Circle’s subclasses will implement it differently. Advantanges of object-oriented programming:  Your program focus on data, not on functions. You create a program using objects, not functions.  You define methods to control the access to its data.  Objects communicate through methods - messages Application adapts to new changes.  Objects has unique responsibilities.  You don’t define global data. Every object contains its data. Learn how to use these concepts in SOLID design principles. "
    }, {
    "id": 12,
    "url": "http://localhost:4000/ssl-handshake-failure/",
    "title": "SSL Handshake Failure",
    "body": "2022/05/11 - The Secure Socket Layer (SSL) enables a secured connection between a client and a server. SSL Handshake is a set of steps that make it possible for this secured connection over the network. A summary of the steps in the SSL handshake:  Agree on the version of the cryptographic protocol to use.  Select cryptographic algorithms - cipher suites to use.  Exchange and validate digital certificates to authenticate each other.  Generate a shared secret key using asymmetric encryption techniques. For more information about cryptographic algorithms and digital certificates, refer here. Handshake Failure Scenario: We try to build a Spring WebClient component to consume data from an API Server (target_server). Requisites:  SDK: 1. 8 java version “1. 8. 0_191” Websphere application server123456789101112131415String username= here_username_target_server ;String password =  here_password_target_server ;WebClient webClient = WebClient. builder() . baseUrl( baseUrl_target_server ) . filter(basicAuthentication(username, password)) . build();Mono&lt;String&gt; monoString = webClient . get() . uri( uri_target_server ). accept(MediaType. TEXT_PLAIN) . retrieve() . bodyToMono(String. class). log();logger. info(monoString. block());Once the client is running, throws the following error. 1ERROR WebClientRequestException: Received fatal alert: handshake_failure; nested exception is javax. net. ssl. SSLException: Received fatal alert: handshake_failure)Analysis: We usually check if both parties - client and server - comply with all the steps of the Handshake mechanism. The first two steps deal with cryptographic protocols and cipher suites. What is TLS?: Transport Layer Security (TLS) is a protocol for implementing cryptography on the web. Encrypts data sent over the Internet to ensure hackers cannot see your sensitive information such as passwords or credit card numbers. TLS protocol evolved from Secure Socket Layer (SSL) developed by Netscape to secure web sessions. Cipher Suite: A Cipher Suite is a set of cryptographic algorithms used by an SSL or TLS connection. A suite includes three distinct algorithms:  The key exchange and authentication algorithm.  The encryption algorithm to encipher the data The MAC (Message Authentication Code) algorithm generates the message digest. For example, the Cipher Suite SSL_RSA_WITH_RC4_128_MD5 includes:  The RSA key exchange and authentication algorithm The RC4 encryption algorithm, using a 128-bit key The MD5 MAC algorithmReturning to our scenario, when the client initializes, we see the following lines on the console. 123415:11:23. 567 [main] DEBUG io. netty. handler. ssl. OpenSsl - netty-tcnative not in the classpath; OpenSslEngine will be unavailable. 15:11:24. 939 [main] DEBUG io. netty. handler. ssl. JdkSslContext - Default protocols (JDK): [TLSv1]15:11:24. 939 [main] DEBUG io. netty. handler. ssl. JdkSslContext - Default cipher suites (JDK): [TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, TLS_RSA_WITH_AES_128_GCM_SHA256, TLS_RSA_WITH_AES_128_CBC_SHA, TLS_RSA_WITH_AES_256_CBC_SHA]We can realize Client is using the TLSv1 protocol Now let’s see on the server-side by using an OpenSSL command. (On Windows PC we can use Git Bash) 1openssl s_client -connect &lt;IP&gt;:&lt;PORT&gt;Now, we can see the response. 12345678910111213---SSL handshake has read 5388 bytes and written 473 bytesVerification: OK---New, TLSv1. 2, Cipher is ECDHE-RSA-AES128-GCM-SHA256Server public key is 4096 bitSecure Renegotiation IS supportedCompression: NONEExpansion: NONENo ALPN negotiatedSSL-Session:  Protocol : TLSv1. 2  Cipher  : ECDHE-RSA-AES128-GCM-SHA256The server is using the TLSv1. 2 protocol, that means Client and Server are not using the same protocol version. Solution: From the server response, some ciphers are not supported in the TLSv1. 2 protocol. We can upgrade java version but sometimes is not easy because many applications depend on WebSphere licenses, and we need to wait until the next release. Once we have identified the supported Protocol and Cipher Suites supported by the server, we can modify the ones supported by the Client through the TLS configuration to be able to connect to the Server. Or we can implement the following system property to our Client code. 1System. setProperty( com. ibm. jsse2. overrideDefaultTLS , true );We rerun the Client and see the console. 123416:32:56. 858 [main] DEBUG io. netty. handler. ssl. OpenSsl - netty-tcnative not in the classpath; OpenSslEngine will be unavailable. 16:32:58. 106 [main] DEBUG io. netty. handler. ssl. JdkSslContext - Default protocols (JDK): [TLSv1. 2, TLSv1. 1, TLSv1]16:32:58. 106 [main] DEBUG io. netty. handler. ssl. JdkSslContext - Default cipher suites (JDK): [TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256, TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384, TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA, TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA, TLS_RSA_WITH_AES_128_GCM_SHA256, TLS_RSA_WITH_AES_128_CBC_SHA, TLS_RSA_WITH_AES_256_CBC_SHA]Now Client and Server are agree on the SSL Handshake and can exchange data. "
    }, {
    "id": 13,
    "url": "http://localhost:4000/spring-boot-oauth2/",
    "title": "Spring Boot, OpenAPI3, and OAuth2",
    "body": "2022/04/26 - This tutorial will show how to integrate OAuth2 with Spring Security in a Spring Boot application with OpenAPI 3. The Spring Boot application I am going to use is based on my previous article: Documenting a SpringBoot REST API with OpenAPI 3 OAuth: OAuth is an authorization framework many companies use to secure access to their protected resources. It performs this by using access tokens. The token represents a delegated right of access on behalf of the resource owner. Roles: OAuth defines four roles    The Resource Owner is the user who grants access to a protected resource.     Resource Server stores users’ data and HTTP services and responds to protected resource requests using access tokens.     The client is the application that requires access to protected resources on behalf of the resource owner and its authorization.     The authorization server is responsible for authenticating the user’s identity and giving an authorization token.  Authorization grant: An authorization grant is a credential representing the resource owner’s authorization used by the client to obtain an access token. OAuth defines four grant types.    Authorization Code, for web apps that are server-side apps     Implicit, optimized for clients implemented in a browser using a scripting language such as JavaScript     Resource Owner Password Credentials are used when there is a high degree of trust between the resource owner and the client     Client Credentials are used when the client is requesting access to protected resources based on an authorization previously arranged with the authorization server.  The Client Credentials grant type is the most appropriate for server-to-server applications, such as typical B2B interactions. Getting Started: We add the Spring Oauth dependency to our pom. xml file. 12345&lt;dependency&gt; &lt;groupId&gt;org. springframework. security. oauth. boot&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2-autoconfigure&lt;/artifactId&gt; &lt;version&gt;2. 5. 1&lt;/version&gt;&lt;/dependency&gt;Enable Authorization Server Support: We open the main application class and add @EnableAuthorizationServer to enable the support for the authorization server. 1234567@EnableAuthorizationServer@SpringBootApplicationpublic class OpenapiApplication {	public static void main(String[] args) {		SpringApplication. run(OpenapiApplication. class, args);	}}@EnableAuthorizationServer enables the client credentials grant type by default. Creating ClientId and Client Secret: Open/create the resources/application. yml file and add the following properties: 12345678security: oauth2:  client:   client-id: codercuy-client   client-secret: strong-secret   scope:    - read    - writeWe need to tell Spring which endpoints -resources- must be authenticated. Otherwise, all requests will skip security. Enable Resource Server Support: Create a class that extends ResourceServerConfigurerAdapter and add the following code. 123456789101112@Configuration@EnableResourceServerpublic class OAuth2ResourceServer extends ResourceServerConfigurerAdapter{ @Override public void configure(HttpSecurity http) throws Exception {  http      . authorizeRequests()      . antMatchers( /api/** ). authenticated()      . antMatchers( / ). permitAll(); }}Now, run the main application. http://localhost:8080/swagger-ui. html And try to insert a book (Try out button). In the bookAuthorization parameter, write anything (“key,” for example). Then you receive an error.  Why does this happen? Well, we need to tell OpenAPI that configures security. Configure OpenAPI and Oauth2: Open OpenApiConfig class and add the new code. 123456789101112131415161718192021222324252627282930@Configurationpublic class OpenApiConfig { @Bean public OpenAPI customOpenAPI() {  return new OpenAPI()    . components(new Components()        . addSecuritySchemes( spring_oauth , new SecurityScheme()            . type(SecurityScheme. Type. OAUTH2)            . description( Oauth2 flow )            . flows(new OAuthFlows()                . clientCredentials(new OAuthFlow()                    . tokenUrl( http://localhost:8080  +  /oauth/token )                    . scopes(new Scopes()                        . addString( read ,  for read operations )                        . addString( write ,  for write operations )                    ))))    )      . security(Arrays. asList(          new SecurityRequirement(). addList( spring_oauth )))    . info(new Info()      . title( Book Application API )      . description( This is a sample Spring Boot RESTful service using springdoc-openapi and OpenAPI 3.  )      . termsOfService( terms )      . contact(new Contact(). email( codersitedev@gmail. com ). name( Developer: Moises Gamio ))      . license(new License(). name( GNU ))      . version( 2. 0 )    ); }}From the previous code, you can see that before setting up a security requirement in OpenAPI, we need to define a new security scheme component called “spring_oauth” for example. Now, rerun the main application, and we can see a new green button called Authorize. Then enter the credentials and the scope.  Close the pop-up and try out again to insert a book.  Yes, you did it! Now, your endpoints are secured. "
    }, {
    "id": 14,
    "url": "http://localhost:4000/uml-diagrams-for-java-developers/",
    "title": "UML Diagrams for Java Developers",
    "body": "2022/03/09 - The Unified Modeling Language is a graphical notation for modeling systems and conveying User software requirements. All developers must understand this notation before starting programming. UML is not only pretty pictures. Instead, they communicate the software design decisions to programmers. Use case: As entrepreneurs, we usually pay for costly advertisements to promote our products. We can create a little application to make our ads, promote them as printed flyers, and reduce our investments in ads. Every developer can abstract the main components from a user requirement differently. Having a standard UML notation helps to eliminate ambiguities about the requirements from the beginning. I want to show you how to translate business requirements into technical solutions with this use case. User requirement: Given a text message, a URL link, and an image, build a service that automates the composition of flyer design, including the image, text, and the QR code for the link in a PDF file with an A4 format divided into one, two, four or eight parts ready to print.  From the user requirement, we can realize that we need a task to create a QR code, a job to manipulate elements inside an image, and a task to create a PDF file. We can implement our code or reuse external libraries as dependencies, but the following figure shows the desired result, whatever the implementation approach is chosen.  Why do we model?:  We build models to understand better the system we are developing.  Models document the design decisions we have made.  Models allow an open discussion in the development team before starting programming.  It speeds up the implementation stage because potential technical issues are discussed during the design stage. Visualizing software architecture - design proposal: The C4 model enables software development teams to describe and communicate software design decisions, similar to Google maps zooming in and out of an area of interest. These areas of interest in the software are: Context -&gt; Containers -&gt; Components -&gt; Code - UML Notation Context diagram: A system context diagram shows the big picture. This diagram shows actors and software systems rather than technologies. For our use case, it says that building a new web application will achieve the user requirement.  Container diagram: The container diagram shows how the responsibilities are distributed in different execution units - containers. We need a Form on the front end and an API application on the back end for our web application.  Component diagram: As system analysts, we delegate responsibilities to software elements called components or services that execute sub-tasks with specific technologies to achieve the user software requirements. Read the Single Responsibility Principle. The API application interacts with the user requests. Then, delegates the following subtasks to different services.  Generate a QR Code based on the URL link achieved by the QR Service.  Merge the previous QR Code, text message, and image in a final image design performed by the Image Service.  Build a PDF file that includes the last design image achieved by the PDF Service. The API application returns the final image design in a PDF file to the user.  It’s better to include a new service called FlyerComposerService between the API application and the three services. It facilitates the migration task if you want to adopt a microservices architecture. The FlyerComposerService class is responsible for orchestrating all calls to these three last services. UML Class Notation: A class is a template for creating objects providing initial values for state (attributes) and behavior (operations). Each attribute has a type. Each operation has a signature.  From the figure above:  The first compartment describes the class name.  The second compartment describes the attributes with its visibility, private(-) or public(+), and their types.  The third compartment describes the operations and their return types. The following section shows how these compartments are translated into code. 123456789101112131415public class FlyerComposerService { private QRService qrService; private ImageService imageService; private PDFService pdfService;  public byte[] composeFlyer(String[] qrText,  String text,  byte[] image,  int nroFlyers)  .   //code omitted }}Relationships between classes: UML conveys how a class is related to other classes. Let’s see the kind of relationships that matter to our design. Dependency: Dependency is a relationship used to show that some class requires or depends on another class or interface. In other words, some class provides (supplier) particular functionalities that others require (client). At the FlyerComposerService class above, we can see how is declared the dependencies as member variables. Realization: Realization is a relationship where one class realizes or implements the specification defined in another class (usually an interface). Defining and creating interfaces is an excellent approach to building software to is extendable. Read the Open-Closed Principle. The implemented code reflects the intent of the UML designer. : The following figure conveys the Class diagram.  For example, we can see how the QRService interface is implemented into code. 123public interface QRService { byte[] generateQRCode(String qrText) throws Exception;}In addition, we can see how the QRServiceImpl class is implemented into code 1234567public class QRServiceImpl implements QRService { @Override public byte[] generateQRCode(String qrText) throws Exception { .  //code omitted }}Conclusions:  UML convey how to build the software without ambiguities, e. g. , build first an interface instead of a class.  Modeling through UML yields an understanding of a system.  An explicit UML class diagram facilitates communication between developers. We will see how to implement every Spring Boot service in the following articles, so follow me! "
    }, {
    "id": 15,
    "url": "http://localhost:4000/open-closed-principle/",
    "title": "SOLID principles: The Open-Closed Principle (Part II)",
    "body": "2022/01/06 - SOLID principles tell you how to arrange your functions into classes and how those classes should be interrelated. When SOLID principles are applied correctly, your software infrastructure will be able to tolerate changes, it will be easier to understand, and it will be focuser on reusable components. After looking at the Single Responsibility Principle, let’s continue with the second principle. SOLID principles: The Open-Closed Principle (OCP):  … “a module, class, or function should be open for extension but closed for modification. “ Bertrand Meyer coined the principle, suggesting that we should build software to be extendable without touching its current code implementation. For instance, imagine designing and implementing a rate limit algorithm to control the number of requests allowed for every endpoint in a REST API. The RateLimit class implements an interceptor - HandlerInterceptor - that allows an application to intercept HTTP requests before they reach the service, so we can either let the request go through or block it and send back the status code 429. The team wants to retrieve the number of requests by plan from a text file. The following getAPIPlans method retrieves those parameters. 123456789101112131415161718192021222324252627282930public class RateLimit implements HandlerInterceptor { private Map&lt;String, Long&gt; apiPlans;  @Override public boolean preHandle(HttpServletRequest request,   HttpServletResponse response, Object handler) throws Exception {  //getClientId  apiPlans = getAPIPlans();  //build Buckets  //evaluate request per clientId  //accept(200) or refuse(429) request }  private Map&lt;String, Long&gt; getAPIPlans() throws Exception {  Map&lt;String, Long&gt; apiPlans = new ConcurrentHashMap&lt;&gt;();  Resource resource = new ClassPathResource( apiPlans. txt );  try {   List&lt;String&gt; allLines = Files. readAllLines(Paths. get(resource. getURI()));   for (String line: allLines) {	  String[] attributes = line. split( : ); 	  String plan = attributes[0];	  long capacity = Long. valueOf(attributes[1]). longValue();	  apiPlans. put(plan, capacity);   }  } catch (IOException e) {    throw new RuntimeException(e. getMessage());  }  return apiPlans; }}Suddenly an unexpected scenario arises. : The developer leaves the company, and a new one arrives—for example, You. As developers, we usually receive tasks to do maintenance in projects that do not belong to us; specifically, we never created that code. Then weeks later, your team decides that must be retrieved parameters from a database. Therefore you proceed to replace the getAPIPlans method; then, you break the open-closed principle. That is the meaning of the principle; you can not touch the code that is already implemented and working for a long time. Suppose the code is too complex to understand, not well documented, and includes a lot of dependencies. In that case, we have a lot of probabilities to introduce a bug or break some functionalities that we cannot visualize. Unless it is a bug that we have to fix, we should never modify the existing code. Even if the code is not well designed or does not follow well object-oriented principles, it could not be easy to extend a class to introduce new functionalities. The team implements the open-closed principle to support future changes for this scenario. To refactor the code, we adopt polymorphism and aggregation. Polymorphism: Polymorphism is part of the core concepts of Object-Oriented Programming and means many forms, allowing an object to behave differently in some instances. For our scenario, polymorphism will enable the getAPIPlans method to achieve its goals in different ways: retrieve the parameters from a text file or a database. Aggregation: Aggregation defines a HAS-A relationship between two classes. Their objects have their life cycle, but one of them is the owner of the HAS-A relationship. The following diagram shows the goal of our design.  Enabling the Open-Closed Principle: Firstly, and thinking abstractly, you should create an interface and define a contract that will include all required functionalities. 12345public interface DataService { public Map&lt;String, Long&gt; getAPIPlans() throws Exception;}Secondly, we move our getAPIPlans method to a new class that implements the previous interface. 123456789public class TextData implements DataService { @Override public Map&lt;String, Long&gt; getAPIPlans() throws Exception {  Map&lt;String, Long&gt; apiPlans = new ConcurrentHashMap&lt;&gt;();  //code omitted	  return apiPlans; }}Thanks to abstractions, we can create a new class to implement getAPIPlans with different behavior, in this case, to retrieve parameters from a database. 1234567891011121314151617public class DBData implements DataService { private DataSource datasource;  public DBData(DataSource datasource) {  this. datasource = datasource; }  @Override public Map&lt;String, Long&gt; getAPIPlans() throws Exception {  Map&lt;String, Long&gt; apiPlans = new ConcurrentHashMap&lt;&gt;();  for (Plan plan : datasource. getAPIPlans()) {  //code omitted	   }  return apiPlans; }}Introducing a new abstraction layer with different implementations avoids tight coupling between classes. Finally, we refactor our RateLimit class aggregating an instance of DataService type in its constructor method. 123456789101112131415161718public class RateLimit implements HandlerInterceptor { private Map&lt;String, Long&gt; apiPlans; private DataService dataService;  public RateLimit(DataService dataService) {  this. dataService = dataService; }  @Override public boolean preHandle(HttpServletRequest request,   HttpServletResponse response, Object handler) throws Exception {  //getClientId  apiPlans = dataService. getAPIPlans();  //build Buckets  //evaluate request per clientId  //accept(200) or refuse(429) request }}If later we decided to retrieve the parameters from a NoSQL database, we would no longer have to touch the code, create a new class that implements getAPIPlans, and instantiate this new class in RateLimit. Even if, instead of implementing the HandlerInterceptor interface, we implement a Filter to design our Rate Limit algorithm, we can reuse the DataService interface as one of its dependencies. Calling to getAPIPlans is now fixed (closed for modification). If we want it to behave differently, we implement it in a new class (open for extension) that will follow the contracts defined in our interface. Our new DBData dependency is instantiated in our RateLimit class thanks to the magic of the Dependency Injection principle, which I will explain in a near-future article, so follow me!. "
    }, {
    "id": 16,
    "url": "http://localhost:4000/shopping-options/",
    "title": "Shopping options",
    "body": "2021/12/28 - An Amazon customer wants to buy a pair of jeans, a pair of shoes, a skirt, and a top but has a limited budget in dollars. Given different pricing options for each product, determine how many options our customer has to buy 1 of each product. You cannot spend more money than the budgeted amount. Example priceOfJeans = [2,3] priceOfShoes = [4] priceOfSkirts = [2,3] priceOfTops = [1,2] budgeted = 10 The customer must buy shoes for 4 dollars since there is only one option. This leaves 6 dollars to spend on the other 3 items. Combinations of prices paid for jeans, skirts, and tops respectively that add up to 6 dollars or less are [2,2,2], [2,2,1], [3,2,1], [2,3,1]. There are 4 ways the customer can purchase all 4 items. Function description: Create a function that returns an integer representing the number of options present to buy the four items. The function must have 5 parameters: int[] priceOfJeans: An integer array containing the prices of the pairs of jeans available. int[] priceOfShoes: An integer array containing the prices of the pairs of shoes available. int[] priceOfSkirts: An integer array containing the prices of the skirts available. int[] priceOfTops: An integer array containing the prices of the tops available. int dollars: the total number of dollars available to shop with. Constraints 1 ≤ length(priceOfJeans, priceOfShoes, priceOfSkirts, priceOfTops) ≤ 1000 1 ≤ dollars, prices ≤ 1000000000 Solution: To find how many ways the customer can purchase all four items, we can iterate the four arrays, combine all its products, and validate that he/she cannot spend more money than the budgeted amount. Here is our assumption based on a Test case. 123456789@Testpublic void test_shoppingOptions() { int[] priceOfJeans = {2, 3}; int[] priceOfShoes = {4}; int[] priceOfSkirts = {2, 3}; int[] priceOfTops = {1, 2}; assertEquals(4, ShoppingOptions. getNumberOfOptions(priceOfJeans, priceOfShoes,     priceOfSkirts, priceOfTops, 10));}We proceed to implement the algorithm that includes all possible input validations. The for-each construct helps our code be elegant and readable and there is no use of the index. See clean code practices. 12345678910111213141516171819202122232425262728293031323334353637383940414243public class ShoppingOptions { public static int getNumberOfOptions(int[] priceOfJeans,  int[] priceOfShoes, int[] priceOfSkirts, int[] priceOfTops, int dollars) {  if (dollars &lt; 1 || dollars &gt; 1000000000)   throw new RuntimeException( wrong value for budget );  if (priceOfJeans. length &lt; 1 || priceOfJeans. length &gt; 1000)   throw new RuntimeException( wrong size in array: priceOfJeans );  if (priceOfShoes. length &lt; 1 || priceOfShoes. length &gt; 1000)   throw new RuntimeException( wrong size in array: priceOfShoes );  if (priceOfSkirts. length &lt; 1 || priceOfSkirts. length &gt; 1000)   throw new RuntimeException( wrong size in array: priceOfSkirts );  if (priceOfTops. length &lt; 1 || priceOfTops. length &gt; 1000)   throw new RuntimeException( wrong size in array: priceOfJeans );  for (int priceOfJean : priceOfJeans) {   if (priceOfJean &lt; 1 || priceOfJean &gt; 1000000000)    throw new RuntimeException( wrong value in array: priceOfJeans );  }  for (int priceOfShoe : priceOfShoes) {   if (priceOfShoe &lt; 1 || priceOfShoe &gt; 1000000000)    throw new RuntimeException( wrong value in array: priceOfShoes );  }  for (int priceOfSkirt : priceOfSkirts) {   if (priceOfSkirt &lt; 1 || priceOfSkirt &gt; 1000000000)    throw new RuntimeException( wrong value in array: priceOfSkirts );  }  for (int priceOfTop : priceOfTops) {   if (priceOfTop &lt; 1 || priceOfTop &gt; 1000000000)    throw new RuntimeException( wrong value in array: priceOfTops );  }  int numberOfOptions = 0;  for (int priceOfJean : priceOfJeans) {   for (int priceOfShoe : priceOfShoes) {    for (int priceOfSkirt : priceOfSkirts) {     for (int priceOfTop : priceOfTops) {      if (priceOfJean + priceOfShoe + priceOfSkirt + priceOfTop &lt;= dollars)       numberOfOptions +=1;     }    }   }  }  return numberOfOptions; }}A function or method should be small, making it easier to read and understand. Therefore, we refactor our code, moving all validations to a private method. The following code shows a new implementation of our algorithm. 12345678910111213141516171819202122232425262728293031323334public class ShoppingOptions { public static int getNumberOfOptions(int[] priceOfJeans,  int[] priceOfShoes, int[] priceOfSkirts, int[] priceOfTops, int dollars) {  if (dollars &lt; 1 || dollars &gt; 1000000000)   throw new RuntimeException( wrong value for budget );  validate(priceOfJeans,  jeans );  validate(priceOfShoes,  shoes );  validate(priceOfSkirts,  skirts );  validate(priceOfTops,  tops );  int numberOfOptions = 0;  for (int priceOfJean : priceOfJeans) {   for (int priceOfShoe : priceOfShoes) {    for (int priceOfSkirt : priceOfSkirts) {     for (int priceOfTop : priceOfTops) {      if (priceOfJean + priceOfShoe + priceOfSkirt + priceOfTop &lt;= dollars)       numberOfOptions +=1;     }    }   }  }  return numberOfOptions; } private static void validate(int[] array, String arrayName) {  if (array. length &lt; 1 || array. length &gt; 1000)   throw new RuntimeException( wrong size in array   + arrayName);  for (int price : array) {   if (price &lt; 1 || price &gt; 1000000000)    throw new RuntimeException( wrong value in array   + arrayName);  } }}This algorithm works fine when array size and values are small. But based on the constraints, imagine you are processing a priceOfShoe value of 100000 at the location priceOfShoes[101], and at that moment, the sum of priceOfJean + priceOfShoe is greater than 10 dollars. Therefore, it does not sense to continue processing the following possible 1000000000 items of pricesOfSkits[] and other 1000000000 items of priceOfTops[]. We need to skip this particular iteration and use “continue” to order process the next priceOfShoe at the location priceOfShoes[102], for example. We create a new test case with big prices. You can add more items to the arrays. 12345678910111213@Test public void test_shoppingOptionsBigPrices() {  int[] priceOfJeans = {2,10000,3,10000,10000,10000,10000,10000,10000,10000,10000,10000,10000,10000,10000,10000,10000,10000,10000,10000,10000,10000,10000,      10000,10000,10000,10000,10000,10000,10000,10000,10000,10000,10000,10000,10000,10000,10000,10000,10000,10000};  int[] priceOfShoes = {2000002,4,2000002,200000,400000,200000,400000,200000,400000,200000,400000,200000,400000,200000,400000,200000,400000,200000,400000,200000,400000,      200000,400000,200000,400000,200000,400000,200000,400000,200000,400000,200000,400000,200000,400000,200000,400000,200000,400000};  int[] priceOfSkirts = {2,3000000,3,3000000,6000000,3000000,6000000,6000000,3000000,6000000,6000000,3000000,6000000,6000000,3000000,6000000,6000000,3000000,6000000,6000000,3000000,6000000,      3000000,6000000,3000000,6000000,6000000,3000000,6000000,6000000,3000000,6000000,6000000,3000000,6000000,6000000,3000000,6000000,6000000,3000000,6000000};  int[] priceOfTops = {1,2,3000000,3000000,7000000,3000000,7000000,3000000,7000000,3000000,7000000,3000000,7000000,3000000,7000000,3000000,7000000,3000000,7000000,      3000000,3000000,7000000,3000000,7000000,3000000,7000000,3000000,7000000,3000000,7000000,3000000,7000000,3000000,7000000,3000000,7000000};  assertEquals(4, ShoppingOptions. getNumberOfOptions(priceOfJeans, priceOfShoes,      priceOfSkirts, priceOfTops, 10)); }We run the test against the previous implementation, and the second test takes 32 ms on average. The execution time could increase if we complete the max size of our arrays.  The following listing shows an optimized solution. 12345678910111213141516171819202122232425262728293031323334353637383940public class ShoppingOptions { public static int getNumberOfOptions(int[] priceOfJeans,  int[] priceOfShoes, int[] priceOfSkirts, int[] priceOfTops, int dollars) {  if (dollars &lt; 1 || dollars &gt; 1000000000)   throw new RuntimeException( wrong value for budget );  validate(priceOfJeans,  jeans );  validate(priceOfShoes,  shoes );  validate(priceOfSkirts,  skirts );  validate(priceOfTops,  tops );  int numberOfOptions = 0;  for (int priceOfJean : priceOfJeans) {   if (priceOfJean &gt;= dollars)    continue;   for (int priceOfShoe : priceOfShoes) {    if (priceOfJean + priceOfShoe &gt;= dollars)     continue;    for (int priceOfSkirt : priceOfSkirts) {     if (priceOfJean + priceOfShoe + priceOfSkirt &gt;= dollars)      continue;     for (int priceOfTop : priceOfTops) {      if (priceOfJean + priceOfShoe + priceOfSkirt + priceOfTop &lt;= dollars)       numberOfOptions +=1;     }    }   }  }  return numberOfOptions; } private static void validate(int[] array, String arrayName) {  if (array. length &lt; 1 || array. length &gt; 1000)   throw new RuntimeException( wrong size in array   + arrayName);  for (int price : array) {   if (price &lt; 1 || price &gt; 1000000000)    throw new RuntimeException( wrong value in array   + arrayName);  } }}We can see the new execution time.  Well, what happens when our possible right prices are located at the end of the arrays?. One possible solution could be to sort the arrays before iterating and find the right combinations of prices. Understanding the inner workings of common data structures and algorithms is a must for Java developers. Learn more "
    }, {
    "id": 17,
    "url": "http://localhost:4000/merge-two-sorted-lists/",
    "title": "Merge two Sorted Lists",
    "body": "2021/08/04 - A merging algorithm takes two sorted lists as input and produces a single list as output, containing all the elements of the two inputs lists in sorted order. Problem: Given two sorted lists, merge them in a new sorted list.  Solution: We can join the two lists into a new list and apply a sort algorithm such as bubble sort, insertion, or quicksort. What we are going to do is to implement a new algorithm with a NlogN performance.  We define a new List to add all elements from the other two lists in a sorted way.  We define two indexes that point to every element in every list We iterate both lists while still exist elements in both lists We compare elements from both lists and add the smaller one to the new list in every iteration. Before passing to the next iteration, we increment in one the index of the list, which contains the smaller element.  If there is a list that still contains elements, we add them directly to the new list. A test case helps to validate your assumptions: Our assumption based on a test case: 123456789101112131415@Testpublic void mergeSortedLists() { List&lt;Integer&gt; sList1 = Arrays. asList(1,1,2,5,8); List&lt;Integer&gt; sList2 = Arrays. asList(3,4,6); assertEquals( [1, 1, 2, 3, 4, 5, 6, 8] ,    SortedList. merge_sorted(sList1,sList2). toString());}@Testpublic void mergeSortedLists2() { List&lt;Integer&gt; sList1 = Arrays. asList(2,4,5); List&lt;Integer&gt; sList2 = Arrays. asList(1,3,6); assertEquals( [1, 2, 3, 4, 5, 6] ,   SortedList. merge_sorted(sList1,sList2). toString());}Here, the implementation code: 123456789101112131415161718192021public class SortedList { public static List&lt;Integer&gt; merge_sorted(  List&lt;Integer&gt; sList1, List&lt;Integer&gt; sList2) {  List&lt;Integer&gt; mergedSortedList = new ArrayList&lt;&gt;();  int idx1 = 0;  int idx2 = 0;  while (idx1 &lt; sList1. size() &amp;&amp; idx2 &lt; sList2. size()) {   if (sList1. get(idx1) &lt;= sList2. get(idx2)) {    mergedSortedList. add(sList1. get(idx1));    idx1++;   } else {    mergedSortedList. add(sList2. get(idx2));    idx2++;   }  }  return mergedSortedList; }}The previous algorithm is missing how to proceed when one of the lists still contains elements not compared. Keep reading here "
    }, {
    "id": 18,
    "url": "http://localhost:4000/hot-warm-architecture-elasticsearch/",
    "title": "Hot-Warm Architecture in Elasticsearch 1/n",
    "body": "2021/02/26 - Elasticsearch is a distributed real-time document store where every field is indexed and searchable. Hot-warm architecture is a way to separate an Elasticsearch deployment into “hot” data nodes and “warm” data nodes. In Hot nodes, You are actively querying and writing to your index. In Warm nodes, You are still querying your index, but it is read-only. In Cold nodes, You are querying your index less frequently. You can deploy it to less performant hardware. Problem: When we need to identify bottlenecks, errors, heavy traffic issues, slow-running queries, and more, we usually analyze our web server logs. But this task is tedious because the logs are distributed in a cluster that contains several web servers machines. Solution: We are going to install a Hot-Cold Logging Cluster on the Elasticsearch Service as shown in the following figure.  Installation: We have the following IP addresses (Three Windows Servers): master  110. 1. 0. 101hotnode 110. 1. 0. 102coldnode 110. 1. 0. 103Open Windows Defender Firewall and add the following rule for the three machines: For the hotnode add an extra 5044 port to the rule if you want to install logstash in that machine. Configure Elasticsearch cluster settings at Master Node: Open …/elasticsearch. yml and copy the following content. bootstrap. memory_lock: truecluster. initial_master_nodes: - masternode. codersite. devcluster. name: elasticprodhttp. port: 9200network. host: 110. 1. 0. 101node. data: falsenode. ingest: falsenode. master: truenode. max_local_storage_nodes: 1node. name: masternode. codersite. devpath. data: E:\ProgramData\Elastic\Elasticsearch\datapath. logs: E:\ProgramData\Elastic\Elasticsearch\logstransport. tcp. port: 9300xpack. license. self_generated. type: basicxpack. security. enabled: falsediscovery. seed_hosts: [ 110. 1. 0. 102:9300 ,  110. 1. 0. 103:9300 ]path. repo: E:\repoCheck the installation with the following command: C:\. . . \codersite. dev&gt;curl -XGET http://110. 1. 0. 101:9200/_cat/health?v=trueepoch   timestamp cluster   status node. total node. data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent1611057767 12:02:47 elasticprod green      1     0   0  0  0  0    0       0         -        100. 0%Configure Elasticsearch cluster settings at Hot Node: bootstrap. memory_lock: truecluster. name: elasticproddiscovery. seed_hosts: - 110. 1. 0. 101:9300 - 110. 1. 0. 103:9300http. port: 9200network. host: 110. 1. 0. 102:9300node. data: truenode. ingest: falsenode. master: falsenode. max_local_storage_nodes: 1node. name: hotnode. codersite. devpath. data: E:\ProgramData\Elastic\Elasticsearch\datapath. logs: E:\ProgramData\Elastic\Elasticsearch\logstransport. tcp. port: 9300xpack. license. self_generated. type: basicxpack. security. enabled: falsecluster. initial_master_nodes: masternode. codersite. devpath. repo: E:\reponode. attr. box_type: hotCheck the installation with the following command: C:\. . . \codersite. dev&gt;curl -XGET http://110. 1. 0. 101:9200/_cat/nodes110. 1. 0. 101 4 66 0  lmr   * masternode. codersite. dev110. 1. 0. 102 1 60 8  cdhlrstw - hotnode. codersite. devConfigure Elasticsearch cluster settings at Cold Node: bootstrap. memory_lock: truecluster. name: elasticproddiscovery. seed_hosts: - 110. 1. 0. 101:9300 - 110. 1. 0. 102:9300http. port: 9200network. host: 110. 1. 0. 103node. data: truenode. ingest: falsenode. master: falsenode. max_local_storage_nodes: 1node. name: coldnode. codersite. devpath. data: E:\ProgramData\Elastic\Elasticsearch\datapath. logs: E:\ProgramData\Elastic\Elasticsearch\logstransport. tcp. port: 9300xpack. license. self_generated. type: basicxpack. security. enabled: falsecluster. initial_master_nodes: masternode. codersite. devpath. repo: E:\reponode. attr. box_type: coldCheck the installation with the following command: C:\. . . \codersite. dev&gt;curl -XGET http://110. 1. 0. 101:9200/_cat/nodes110. 1. 0. 101 5 66 0  lmr   * masternode. codersite. dev110. 1. 0. 102 1 60 0  cdhlrstw - hotnode. codersite. dev110. 1. 0. 103 2 66 25  cdhlrstw - coldnode. codersite. devNow you can proceed to install kibana and logstash. Here you can read an article which explain Elasticsearch as simple as possible. If you want to know how to scale in a distribuited system, I recommend this book: Designing Data-Intensive Applications. If you want to know how to exploit logs data from elastic to set up a rate-limit algorithm, follow me, I will explain it in a near-future article!. "
    }, {
    "id": 19,
    "url": "http://localhost:4000/clean-code/",
    "title": "Clean Code",
    "body": "2020/10/27 - Clean code can be read and enhanced by a developer other than its original author. This kind of practice Robert C Martin introduced it. If you want to be a better programmer, you must follow these recommendations. . Clean Code has Intention-Revealing names: Names reveal intent. Someone who reads your code must understand the purpose of your variable, function, or class. Real situation: 12int sId; //supplier Idint artDelPrice;It must be refactored to this: 12int supplierId;int articleDeliveredPrice;Even with external dependencies: 1private Z_E2F_RS_Result e2fResult: //ingredients recordsetIt must be refactored to this: 1private Z_E2F_RS_Result ingredients:Imagine that we dont have the //ingredients comment in e2fResult variable. Then, further in any part of our code, when we try to process this variable, we have the following sentence: 1e2f = e2fResult[i]And we don’t know what does e2f means!. Well, someone suggests asking the person responsible for this code. But that guy is not at the office. Well, send it an email, and he is on holiday!. But if instead we adopt names which reveal intent from beginning, we could avoid these catastrophic scenarios. 1ingredient = ingredients[i]Clean Code tells a story: When we try to fix bugs, when analyzing the secuence of actions (functions, methods), we realize the code does not communicate well the logical flow of these actions. It’s a nightmare to decode the meaning of these actions. This will always happen because our initial design based on the initial requirements change over time. As developers, we are responsible for refactoring our code to made it a simple story that everybody can understand. For example, look at the following code: 1234567891011ACMEWebServiceClient. login();if (process. equals( core ) {  ACMEWebServiceClient. transfer_buyersCoreData_to_ACME();}if (process. equals( status )) {  ACMEWebServiceClient. transfer_buyersStatusChanges_to_ACME();}if (process. equals( events )) {  ACMEWebServiceClient. transfer_events_to_ACME();}ACMEServiceClient. logout();Other recommendations of clean code are:  Clean Code separates levels of detail Clean Code needs a few comments Clean Code has small methods Clean Code has Command/Query separationYou can see a lot of typical algorithms implemented with Clean Code principles in the following link "
    }, {
    "id": 20,
    "url": "http://localhost:4000/documenting-rest-api-openapi3/",
    "title": "Documenting a SpringBoot REST API with OpenAPI 3",
    "body": "2020/10/02 - The main idea for documenting our back-end RESTful APIs is to communicate to third-party developers what our endpoints are doing. To learn more about REST see Representational State Transfer. Prerequisites:  Java 8. x Maven 3. xSteps: 1. Create the maven project: Go to spring initializr and add the following dependencies: Once you generate the JAR maven project, open it in your favorite IDE. Below, you can see the pom. xml to use: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version= 1. 0  encoding= UTF-8 ?&gt;&lt;project xmlns= http://maven. apache. org/POM/4. 0. 0  xmlns:xsi= http://www. w3. org/2001/XMLSchema-instance 	xsi:schemaLocation= http://maven. apache. org/POM/4. 0. 0 https://maven. apache. org/xsd/maven-4. 0. 0. xsd &gt;	&lt;modelVersion&gt;4. 0. 0&lt;/modelVersion&gt;	&lt;parent&gt;		&lt;groupId&gt;org. springframework. boot&lt;/groupId&gt;		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;		&lt;version&gt;2. 3. 4. RELEASE&lt;/version&gt;		&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;	&lt;/parent&gt;	&lt;groupId&gt;com&lt;/groupId&gt;	&lt;artifactId&gt;openapi&lt;/artifactId&gt;	&lt;version&gt;0. 0. 1-SNAPSHOT&lt;/version&gt;	&lt;name&gt;openapi&lt;/name&gt;	&lt;description&gt;openapi in Spring Boot&lt;/description&gt;	&lt;properties&gt;		&lt;java. version&gt;1. 8&lt;/java. version&gt;	&lt;/properties&gt;	&lt;dependencies&gt;		&lt;dependency&gt;			&lt;groupId&gt;org. springframework. boot&lt;/groupId&gt;			&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;dependency&gt;			&lt;groupId&gt;org. springframework. boot&lt;/groupId&gt;			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;			&lt;scope&gt;test&lt;/scope&gt;			&lt;exclusions&gt;				&lt;exclusion&gt;					&lt;groupId&gt;org. junit. vintage&lt;/groupId&gt;					&lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt;				&lt;/exclusion&gt;			&lt;/exclusions&gt;		&lt;/dependency&gt;		&lt;dependency&gt;			&lt;groupId&gt;org. springframework. boot&lt;/groupId&gt;			&lt;artifactId&gt;spring-boot-starter-validation&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;dependency&gt;			&lt;groupId&gt;org. springframework. boot&lt;/groupId&gt;			&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;		&lt;/dependency&gt;		&lt;dependency&gt;			&lt;groupId&gt;com. h2database&lt;/groupId&gt;			&lt;artifactId&gt;h2&lt;/artifactId&gt;			&lt;scope&gt;runtime&lt;/scope&gt;		&lt;/dependency&gt;	&lt;/dependencies&gt;	&lt;build&gt;		&lt;plugins&gt;			&lt;plugin&gt;				&lt;groupId&gt;org. springframework. boot&lt;/groupId&gt;				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;			&lt;/plugin&gt;		&lt;/plugins&gt;	&lt;/build&gt;&lt;/project&gt;To generate automatically the API documentation, we add the springdoc-openapi-ui dependency to our pom. xml file. The main idea for documenting our back-end RESTful APIs is to communicate what our endpoints are doing to third-party developers. 12345&lt;dependency&gt;  &lt;groupId&gt;org. springdoc&lt;/groupId&gt;  &lt;artifactId&gt;springdoc-openapi-ui&lt;/artifactId&gt;  &lt;version&gt;1. 3. 9&lt;/version&gt;&lt;/dependency&gt;2. Configure H2 Database: The H2 in-memory database is volatile, which means data will be lost when we restart the application. We add the following properties to the application. properties file. 12345spring. datasource. url=jdbc:h2:mem:testdbspring. datasource. driverClassName=org. h2. Driverspring. datasource. username=saspring. datasource. password=passwordspring. jpa. database-platform=org. hibernate. dialect. H2Dialect3. Create JPA Entity – Book. java: JPA stands for Java Persistence API and is a Java specification about how to handle relational data. Even when Spring Data provides a standard programming model for different databases, switching from a SQL database to a NoSQL database is impossible without touching the source code. @Entity annotation describes the Book data that will be stored by Spring Data and makes our Book object ready for storage in a JPA-based relational data store. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package com. openapi. model;import com. fasterxml. jackson. annotation. JsonProperty;import io. swagger. v3. oas. annotations. media. Schema;import javax. persistence. *;import javax. validation. constraints. NotBlank;import javax. validation. constraints. Size;@Schema(description =  Book object )@Entity@Table(name= books )public class Book { @JsonProperty(value= id , required=true, index = 10) @Schema(description =  Unique identifier of the Book.  ,   example =  1 , required = true) private long id; @JsonProperty(value= title , required=true, index = 20) @Schema(description =  Name of the title.  ,   example =  Java , required = true) @NotBlank @Size(min = 0, max = 20) private String title; @JsonProperty(value= author , required=true, index = 30) @Schema(description =  Name of the author.  ,   example =  Max Abi , required = true) @NotBlank @Size(min = 0, max = 30) private String author; public Book() {} @Id @GeneratedValue(strategy = GenerationType. AUTO) public long getId() {  return id; } public void setId(long id) {  this. id = id; } @Column(name =  title , nullable = false) public String getTitle() {  return title; } public void setTitle(String title) {  this. title = title; } @Column(name =  author , nullable = false) public String getAuthor() {  return author; } public void setAuthor(String author) {  this. author = author; }}4. Create a String Data Repository – BookRepository. java: Repositories are used to store and access data from different types of databases. Spring Data JPA repository supports creating, reading, updating, and deleting records against our back-end datastore. 123456package com. openapi. respository;import com. openapi. model. Book;import org. springframework. data. jpa. repository. JpaRepository;import org. springframework. stereotype. Repository;@Repositorypublic interface BookRepository extends JpaRepository&lt;Book, Long&gt; {}5. Create Spring Rest Controller Interface – BookApi: We create an Interface to describe the API functionalities with the openapi annotations. In this way, we separate our API contract from the implementation Class. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com. openapi. controller;import com. openapi. model. Book;import io. swagger. v3. oas. annotations. Operation;import io. swagger. v3. oas. annotations. Parameter;import io. swagger. v3. oas. annotations. media. Content;import io. swagger. v3. oas. annotations. media. Schema;import io. swagger. v3. oas. annotations. responses. ApiResponse;import io. swagger. v3. oas. annotations. responses. ApiResponses;import io. swagger. v3. oas. annotations. tags. Tag;import org. springframework. http. HttpStatus;import org. springframework. http. ResponseEntity;import org. springframework. web. bind. annotation. *;import javax. validation. Valid;import javax. validation. constraints. NotNull;import java. util. Collection;@Tag(name =  book , description =  the book API )@RequestMapping( /api/v1/books )public interface BookApi { @Operation(summary =  Find book by ID , description =  Returns a single book , tags = {  book  }) @ApiResponses(value = {   @ApiResponse(responseCode =  200 , description =  successful operation , content = @Content(schema = @Schema(implementation = Book. class))),   @ApiResponse(responseCode =  400 , description =  Invalid ID supplied , content = @Content),   @ApiResponse(responseCode =  404 , description =  Book not found , content = @Content) }) @RequestMapping(value =  /{id} , produces = {  application/json ,  application/vnd. api+json }, method = RequestMethod. GET) @ResponseStatus(HttpStatus. OK) public ResponseEntity&lt;Book&gt; findById(   @Parameter(description =  ID of book , required = true)   @PathVariable long id,   @NotNull @Parameter(description =  select which kind of data to fetch , required = true)   @Valid @RequestHeader(value= bookAuthorization , required = true) String bookAuthorization)   throws Exception; @Operation(summary =  Get books , description =  Returns a books collection , tags = {  book  }) @GetMapping( / ) @ResponseStatus(HttpStatus. OK) public Collection&lt;Book&gt; findBooks(); @PutMapping( /{id} ) @ResponseStatus(HttpStatus. OK) public Book updateBook(@PathVariable( id ) final String id, @RequestBody final Book book); @PatchMapping( /{id} ) @ResponseStatus(HttpStatus. OK) public Book patchBook(@PathVariable( id ) final String id, @RequestBody final Book book); @Operation(summary =  Create book , description =  This can only be done by the logged in book.  , tags = {  book  }) @ApiResponses(value = { @ApiResponse(description =  successful operation , content = { @Content(mediaType =  application/json , schema = @Schema(implementation = Book. class)), @Content(mediaType =  application/xml , schema = @Schema(implementation = Book. class)) }) }) @PostMapping(value =  / , consumes = {  application/json ,  application/xml ,  application/x-www-form-urlencoded  }) @ResponseStatus(HttpStatus. CREATED) public ResponseEntity&lt;Book&gt; postBook(   @NotNull   @Parameter(description =  Created book object , required = true)   @Valid @RequestBody Book body,   @NotNull @Parameter(description =  select which kind of data to fetch , required = true)   @Valid @RequestHeader(value= bookAuthorization , required = true) String bookAuthorization)   throws Exception; @RequestMapping(method = RequestMethod. HEAD, value =  / ) @ResponseStatus(HttpStatus. OK) public Book headBook(); @DeleteMapping( /{id} ) @ResponseStatus(HttpStatus. OK) public long deleteBook(@PathVariable final long id);}6. Create Spring Rest Controller Implementation – BookApiController. java: @RestController annotation tells Spring that this Class describes endpoints that should be made available over the web. The data returned by each method will be included in the response body. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960package com. openapi. controller;import java. util. Collection;import com. openapi. exception. BookNotFoundException;import com. openapi. model. Book;import com. openapi. respository. BookRepository;import org. springframework. beans. factory. annotation. Autowired;import org. springframework. http. HttpStatus;import org. springframework. http. ResponseEntity;import org. springframework. web. bind. annotation. DeleteMapping;import org. springframework. web. bind. annotation. PatchMapping;import org. springframework. web. bind. annotation. PathVariable;import org. springframework. web. bind. annotation. PutMapping;import org. springframework. web. bind. annotation. RequestBody;import org. springframework. web. bind. annotation. RequestMapping;import org. springframework. web. bind. annotation. RequestMethod;import org. springframework. web. bind. annotation. ResponseStatus;import org. springframework. web. bind. annotation. RestController;@RestControllerpublic class BookApiController implements BookApi { @Autowired private BookRepository repository; @Override public ResponseEntity&lt;Book&gt; findById(   long id,   String bookAuthorization) throws Exception {  Book book = repository. findById(id)    . orElseThrow(() -&gt; new BookNotFoundException( Employee not found for this id ::   + id));  return ResponseEntity. ok(). body(book); } @Override public Collection&lt;Book&gt; findBooks() {  return repository. findAll(); } @PutMapping( /{id} ) @ResponseStatus(HttpStatus. OK) public Book updateBook(@PathVariable( id ) final String id, @RequestBody final Book book) {  return book; } @PatchMapping( /{id} ) @ResponseStatus(HttpStatus. OK) public Book patchBook(@PathVariable( id ) final String id, @RequestBody final Book book) {  return book; } @Override public ResponseEntity&lt;Book&gt; postBook(   Book body,   String bookAuthorization) throws Exception {  return new ResponseEntity&lt;Book&gt;(repository. save(body), HttpStatus. CREATED); } @RequestMapping(method = RequestMethod. HEAD, value =  / ) @ResponseStatus(HttpStatus. OK) public Book headBook() {  return new Book(); } @DeleteMapping( /{id} ) @ResponseStatus(HttpStatus. OK) public long deleteBook(@PathVariable final long id) {  return id; }}7. Configure openApi – OpenApiConfig. java: 123456789101112131415161718192021222324package com. openapi. config;import io. swagger. v3. oas. models. info. Info;import io. swagger. v3. oas. models. Components;import io. swagger. v3. oas. models. OpenAPI;import io. swagger. v3. oas. models. info. Contact;import io. swagger. v3. oas. models. info. License;import org. springframework. context. annotation. Bean;import org. springframework. context. annotation. Configuration;@Configurationpublic class OpenApiConfig { @Bean public OpenAPI customOpenAPI() {  return new OpenAPI()    . components(new Components())    . info(new Info()      . title( Book Application API )      . description( This is a sample Spring Boot RESTful service using springdoc-openapi and OpenAPI 3.  )      . termsOfService( terms )      . contact(new Contact(). email( codersitedev@gmail. com ))      . license(new License(). name( GNU ))      . version( 1. 0 )    ); }}8. Running Application: This Spring boot application has an entry point Java class called OpenapiApplication. java, which you can run to start the application. 123456789package com. openapi;import org. springframework. boot. SpringApplication;import org. springframework. boot. autoconfigure. SpringBootApplication;@SpringBootApplicationpublic class OpenapiApplication {	public static void main(String[] args) {		SpringApplication. run(OpenapiApplication. class, args);	}}@SpringBootApplication add the following functionalities:  OpenApiApplication Class becomes a Configuration class.  It enables Component scan, which means looking for other components, configurations, controllers, and services in the com. openapi package.  It enables autoconfiguration; Spring Boot looks for other JAR files in the classpath and configures it automatically, e. g. , H2 database, JPA. Spring Boot will detect and start an embedded Tomcat webserver. 2021-10-28 12:48:02. 659 INFO 9312 --- [ restartedMain] . s. d. r. c. RepositoryConfigurationDelegate : Bootstrapping Spring Data JPA repositories in DEFERRED mode. 2021-10-28 12:48:02. 881 INFO 9312 --- [ restartedMain] . s. d. r. c. RepositoryConfigurationDelegate : Finished Spring Data repository scanning in 201ms. Found 1 JPA repository interfaces. 2021-10-28 12:48:04. 812 INFO 9312 --- [ restartedMain] o. s. b. w. embedded. tomcat. TomcatWebServer : Tomcat initialized with port(s): 8080 (http)2021-10-28 12:48:04. 847 INFO 9312 --- [ restartedMain] o. apache. catalina. core. StandardService  : Starting service [Tomcat]2021-10-28 12:48:04. 848 INFO 9312 --- [ restartedMain] org. apache. catalina. core. StandardEngine : Starting Servlet engine: [Apache Tomcat/9. 0. 38]2021-10-28 12:48:05. 131 INFO 9312 --- [ restartedMain] o. a. c. c. C. [Tomcat]. [localhost]. [/]    : Initializing Spring embedded WebApplicationContext. . . 2021-10-28 12:48:11. 700 INFO 9312 --- [ restartedMain] o. s. b. w. embedded. tomcat. TomcatWebServer : Tomcat started on port(s): 8080 (http) with context path ''2021-10-28 12:48:11. 703 INFO 9312 --- [ restartedMain] DeferredRepositoryInitializationListener : Triggering deferred initialization of Spring Data repositories…2021-10-28 12:48:12. 668 INFO 9312 --- [ restartedMain] DeferredRepositoryInitializationListener : Spring Data repositories initialized!2021-10-28 12:48:12. 704 INFO 9312 --- [ restartedMain] com. openapi. OpenapiApplication      : Started OpenapiApplication in 14. 363 seconds (JVM running for 18. 621)Then, when we run our application, we can see the online documentation at: http://localhost:8080/swagger-ui. html OpenAPI includes a “Try it out” button, which can be used to actually try out the API, not just read its documentation. You can see the source code in the following link: https://github. com/mgamio/openapi-springboot. git Most of the companies usually follow a Design-First API Strategy using SwaggerHub product for example. But the export plugins are not always aligned with the most updated version of OpenAPI. Once you receive the technical specifications in UML, you need to decide whether to take the Design First approach or the Code First approach. Documenting an API facilitates interaction between internal development teams that build different web services for the same product. Let’s now see how to integrate OAuth2 to protect our endpoints. "
    }, {
    "id": 21,
    "url": "http://localhost:4000/big-o-notation-analysis-of-algorithms/",
    "title": "Big O Notation: Analysis of Algorithms - coding interview",
    "body": "2020/06/22 - Big O Notation is a mathematical notation that helps us analyze how complex an algorithm is in terms of time and space. When we build an application for one user or millions of users, it matters. We implement different algorithms to solve one problem and measure how efficient is one respect to the other ones. The first study about Analysis of Algorithms was published by Knuth in 1968. The Art of Computer Programming. Time and Space complexity: Time complexity is related to how many steps takes an algorithm. Space complexity is related to how efficient an algorithm is using the memory and disk. Both terms depend on the input size, the number of items in the input. Moreover, we can analyze the complexity based on three cases:    Best case or Big Omega Ω(n): Usually the algorithm executes in one step independently of the input size.     Average case or Big Theta Θ(n): If the the input size is ramdom     Worst-case or Big O Notation O(n): Gives us an upper bound on the runtime for any input. It gives us a kind of guarantee that the algorithm will never take any longer with a new input size.  Order of growth: The order of growth is related to how the runtime of an algorithm increases when the size of the input increases without limit and tells us how efficient the algorithm is. Therefore, we can compare the relative performance of alternative algorithms. Big O Notation: Common order-of-growth classifications: Big O Notation: examples: O(1) – Constant It does not matter if the input contains 1000 or 1 million items, the code always executes in one step. 123public void constant(List&lt;string&gt; list, String item) { list. add(item);}In a best-case scenario, an add method takes O(1) time. The worst-case scenario takes O(n). O(N) – linear An algorithm runs in O(N) time if the number of steps depends on the number of items included in the input. 1234567public int sum(int[] numbers) { int sum =0; for (int i =0; i&lt;numbers. length; i++) {  sum+=numbers[i]; } return sum;}The main idea in Analysis of Algorithms is always to improve the algorithm performance, by reducing the number of steps and comparisons. You can visit find the smallest number with the same number of digits, for instance. Moreover, the simpler and more intuitive an algorithm is, the more useful and efficient it will be. O(N2) – quadratic If an algorithm includes two loops nested in its code, we could say that it’s running in quadratic time O(N2). For instance, when a 2D matrix is initialized in a tic-tac-toe game. 12345678910private String [][] board;public void initializeBoard(int size) { this. board = new String[size][size]; for (int x = 0; x &lt; size; x++) {  for (int y = 0; y &lt; size; y++) {   board[x][y] =    ;  } }}O(N3) – Cubic When the code includes at the most three nested loops, then the algorithm runs in Cubic time. For example: given N integers, how many triples sum to exactly zero?. One approach (not the best) is to use three nested loops. 1234567891011public int countThreeSum(int[] numbers) { int N =numbers. length; int count =0; for (int i = 0; i&lt;N; i++)  for (int j = i+1; j&lt;N; j++)   for (int k = j+1; k&lt;N; k++)    if (numbers[i] + numbers[j] + numbers[k] == 0)     count++; return count;}O(LogN) – logarithmic This kind of algorithm produces a growth curve that peaks at the beginning and slowly flattens out as the size of the input increase. Log28 = 3 Log216 = 4 Log232 = 5 The binary search uses at most LogN key compares to search in a sorted array of size N. With 8 elements take 3 comparisons, with 16 elements takes 4 comparisons, with 32 elements takes 5 comparisons, and so on. 123456789101112131415public static &lt;T extends Comparable&lt;T&gt;&gt; boolean search(T target, T[] array) { int min = 0; int max = array. length - 1; while (min &lt;= max) {  int mid = (min + max) / 2;  if (target. compareTo(array[mid]) &lt; 0) {   max = mid - 1;  } else if (target. compareTo(array[mid]) &gt; 0) {   min = mid + 1;  } else {   return true;  } } return false;}The complexity of an algorithm: To find the Big O complexity of an algorithm follows the following rules:  Ignore the lower order terms Drop the leading constantsExample: If the time complexity of an algorithm is 2n3 + 4n + 3. Its Big O complexity simplifies to O(n3). How to find the time complexity of an algorithm Given the following algorithm: 12345678public Integer sumEvenNumbers(Integer N) { int sum = 0; for (int number = 1; number &lt;= N; number++)  if ((number % 2) == 0)   sum = sum + number; return sum;}First, we split the code into individual operations and then compute how many times it is being executed as is shown in the following table.       Description   Number of executions         int sum = 0;   1       int number = 1;   1       number &lt;= N;   N       number++   N       if ((number % 2) == 0)   N       sum = sum + number;   N       return sum;   1               Now, we need to sum up how many times each operation is executing. Time complexity = 1 + 1 + N + N + N + N + 1 =&gt;  4N + 3 Why Big O Notation ignores constants?: Big O Notation describes how many steps are required relative to the number of data elements. And it serves as a way to classify the long-term growth rate of algorithms. For instance, for all amounts of data, O(N) will be faster than O(N2) as shown in the following figure: Now, if we compare O(100N) with O(N2), we can see that O(N2) is faster than O(100N) for some amounts of data as shown in the following figure: But after a point, O(100N) becomes faster and remains faster for all increasing amounts of data from that point onward. And that is the reason why Big O Notation ignores constants. Because of this, O(100N) is written as O(N). This article was just an introduction to algorithm analysis to face a real code interview as developers, where they are asked to build rough models. If you want to create a mathematical model for the execution time of a discrete operation, for example, you should take a course in discrete mathematics. Being ready to analyze algorithms requires practice and study of different algorithms, and you can find it in this link with a lot of explanation details. "
    }, {
    "id": 22,
    "url": "http://localhost:4000/solid-principles-the-definitive-guide/",
    "title": "SOLID principles: The Definitive Guide (Part I)",
    "body": "2020/06/15 - SOLID principles tell you how to arrange your functions into classes and how those classes should be interrelated. Robert C. Martin introduced it. Design Principles. When SOLID principles are applied correctly, your software infrastructure will be able to tolerate changes, it will be easier to understand, and it will be focuser on reusable components. Let’s start with the first principle. SOLID principles: Single Responsibility Principle (SRP):  … “a class should only have one reason to change“ This principle states that a class should only have one responsibility. For instance, imagine an online store that issues its cards for its customers, and from the beginning, the Payment and Card teams are in mutual agreement to apply for interest and to lock cards from customers who are in late payments for 14 days or more. In the following code, we have the first design of the Payment Class, which supports both requirements. 12345678910111213public class Payment { public static final int MAX_DAYS = 14;  public void batch(List&lt;Customer&gt; customers) {  for (Customer customer : customers) {   int nDays = latePaymentDays(customer);   if (nDays &gt;= MAX_DAYS) {    applyLatePaymentInterest(customer);    lockCard(customer);   }  } }}The Problem: A Class has more than one responsibility: But suddenly, the Cards team wants to change the validation to 10 days. However, the Payments team manages other policies related to when interests by late payment are applied. As a result, the Payments team enters in disagreement with the Cards team. This scenario is a clear example of how this Class design violates the Single Responsibility Principle because the Payment Class not only has more than one reason to change but also it breaks the business logic of the Payments team. Moreover, both teams are stuck on how to proceed. The following figure shows the Class with different responsibilities: The solution: Create a Class with only one responsibility: What do we need to do?. In this scenario, we can apply the Single Responsibility Principle Firstly, we move the lockCard() responsibility to a new Card Class. This technique is most known as refactoring 123456789101112public class Card { public static final int MAX_DAYS = 10;  public void batch(List customers) {  for (Customer customer : customers) {   int nDays = Payment. latePaymentDays(customer);   if (nDays &gt;= MAX_DAYS) {    lockCard(customer);   }  } }}After that change and following Clean code principles, we can see how it looks the new Payment Class (refactored as well): 123456789101112public class Payment { public static final int MAX_DAYS = 14;  public void batch(List&lt;Customer&gt; customers) {  for (Customer customer : customers) {   int nDays = latePaymentDays(customer);   if (nDays &gt;= MAX_DAYS) {    applyLatePaymentInterest(customer);   }  } }}Finally, new changes to the MAX_DAYS variable will only depend on the requirements of every team separately. The following figure shows the Classes for different actors, without conflicts.  Therefore, the Payment Class is only responsible for supporting to the Payments team, and the Card Class is solely responsible for supporting the Cards team. Also, when new features arrive, then we need to distinct in which Class to include it. Moreover, this is related to the Cohesion concept, which help us to group similar functions inside a Class, and that have the same purpose served by that Class. In conclusion, once you identify classes that have too many responsibilities, use this refactoring technique to create smaller classes with single responsibilities and focused only on one business actor. Use this principle as a tool when translating business software requirements into technical specifications. Programmers must understand these design decisions before programming. Now that you’ve learned the Single Responsibility principle, it’s time to learn the Open-closed principle to avoid future software maintenance costs. "
    }, {
    "id": 23,
    "url": "http://localhost:4000/graphs-depth-first-search/",
    "title": "Graphs: Depth-First Search",
    "body": "2020/06/01 - Depth-First Search (DFS), is an algorithm to search for information in Graphs. A Graph is a non-linear data structure consisting of nodes (or vertices) and edges. Its shape depends on the physical or abstract problem we are trying to solve. For instance, if nodes represent cities, then the routes which connect cities may be represented by no-directed edges. But if nodes represent tasks to complete a project, then their edges must be directed to indicate which task must be completed before another. Graph theory was first proposed by Leonhard Euler when solved the Seven Bridges of Königsber problem. Graphs: Terminology: To describe terms related to Graphs, we use the following Graph, which models Hyperloop transport to be installed in Germany, for instance.  A Graph shows only the relationships between the vertices and the edges. Therefore, the most important here is to understand, which edges are connected to which vertex. Moreover, we can also say that Graph models connections between objects. Adjacency When two vertices are connected by a single edge, then they are adjacent or neighbors. In the figure above, the vertices represented by the cities Berlin and Leipzig are adjacent, but the cities Berlin and Dresden are not. Path A Path is defined as a sequence of edges. The figure above shows a path from Berlin to München, that passes through cities Leipzig and Nürnberg. Therefore, the path is Berlin, Leipzig, Nürnberg, München. Connected Graphs A graph is connected if exists at least one path from every vertex to every other vertex. Therefore, the figure above is connected because connects all cities. Directed and Weighted Graphs A graph is directed when the edges have a direction. In the figure above we have an undirected graph because the hyperloop can usually go either way. From Berlin to Leipzig is the same as from Leipzig to Berlin. A tree is an undirected graph, as long as any two vertices are connected by exactly one path. Graphs are called a weighted graph when edges are given weight. For instance, the distance between cities can be weighted in how fast they are connected. The edges may contain value/cost as well. Acyclic Graphs Versus Cyclic Graphs In Graphs, cycles are paths through edges and vertices that start and end at the same vertex. An acyclic graph has no such cycles. Reasons to use Graphs: One of the questions that a graph can answer is: which cities can be reached from a specified city?. Well, to respond to this question, we need to implement search algorithms. There are two different ways of searching in a graph: depth-first search (DFS) and breadth-first search (BFS). Depth-First Search (DFS): Depth-First Search (DFS) is an algorithm for traversing or searching for in a Graph. The algorithm starts at the root node (selecting some arbitrary city as the root node) and explores as far as possible along each path. The following Graph shows the sequence of cities followed by the DFS algorithm, if we choose Berlin as the root node, for instance.  Implementing Graphs Algorithm: We need an Object which supports any kind of data included in the Node (which includes the information, that we want to represent). We called it Vertex (because comes from a Mathematical concept). Moreover, to avoid searching in cycles, a boolean variable is included, so we will mark each node when we visit it. 123456789public class Vertex { private String name; private boolean visited; public Vertex(String name) {  this. name = name;  this. visited = false; }}To define, that two vertices are connected (through edges), we have two approaches: the adjacency matrix and the adjacency list. The Adjacency Matrix In a graph of N vertices, we create a two-dimensional array of NxN. An edge between two vertices (cities) indicates a connection (two adjacent nodes) and is represented by 1. No connections are represented by 0.  The table above says, Leipzig is adjacent to Berlin, Dresden, and Nürnberg, for instance. Create and Initialize an Abstract Data Type We create an Abstract Data Type called a Graph to define the behavior of our new data structure. We need a stack data structure so we can remember the visited vertices. A stack follows the last-in, first-out (LIFO) principle, i. e. , the city inserted at last is the first city to come out of the stack. We define an arrayOfVertex[] array to store new Vertices(cities) added to the Graph. We define a numOfVertices variable that indicates the number of Vertices already added to the Graph. Since we will pass a String argument (city name) to our DFS algorithm, a mapOfVertex hashMap is defined to register the key-value: city-index, where the index is the City’s location at arrayOfVertex[]. 12345678910111213141516171819202122232425public class Graph { private final int MAX_VERTEX = 15; private Vertex arrayOfVertex[]; //cities private Map mapOfVertex; //matrix of adjacent vertex: private int matrixOfAdjVertex[][]; //register the location at the arrayOfVertex: private int numOfVertices; private Stack stack; public Graph() {  arrayOfVertex = new Vertex[MAX_VERTEX];  mapOfVertex = new ConcurrentHashMap&lt;&gt;();  numOfVertex = 0;  matrixOfAdjVertex = new int[MAX_VERTEX][MAX_VERTEX];  stack = new Stack&lt;&gt;();  //initialize matrix  for (int i = 0; i &lt; MAX_VERTEX; i++) {   for (int j = 0; j &lt; MAX_VERTEX; j++) {    matrixOfAdjVertex[i][j] = 0;   }  } }}Adding a Vertex Before the implementation, we create a Test case with the following assumption: 123456@Testpublic void test_addVertex() { Vertex city = new Vertex( Berlin ); graph. addVertex(city); assertTrue(graph. getMapOfVertex(). size() ==1);}The implementation code register the new city in our mapOfVertex hashMap. 1234public void addVertex(Vertex city) { mapOfVertex. put(city. getName(), numOfVertices); arrayOfVertex[numOfVertices++] =city;}The numOfVertices variable determines the location (index) of the new City in the arrayOfVertex[]. Adding an edge We add two entries to matrixOfAdjVertex, because two cities are connected in both directions. 123456public void addEdge(String city1, String city2) {  int start = mapOfVertex. get(city1);  int end = mapOfVertex. get(city2);  matrixOfAdjVertex[start][end] =1;  matrixOfAdjVertex[end][start] =1;}You can implement your code for these methods. The point here is that we need to define the topology of our Graph, adding Vertices(cities) and edges that connect them. Depth-First Search: The algorithm: We define a dfs() method, which receives the City name as its argument. Then we locate the index of this city in our hashMap, is marked as visited, and push it onto the stack. We iterate the stack until is empty. And this is what we do in every iteration:  We retrieve the Vertex from the top of the stack (peek) We try to retrieve at least one unvisited neighbor for this vertex If one vertex is found, it is marked as visited and pushes it onto the stack If one vertex is not found, we pop the stackIf Berlin were our entry city, then the first adjacent city will be Leipzig, which is marked as visited and push it into the stack. In the next iteration, we read Leipzig (through peek method) from the stack and look for its neighbors. Therefore, following these iterations, we arrive at München. That is the in-depth essence of this algorithm: to explore as far as possible along each branch before continuing with a new one. 123456789101112131415161718public void dfs(String city) {  int vertex = mapOfVertex. get(city);  arrayOfVertex[vertex]. setVisited(true);  System. out. print(city +    );  stack. push(vertex);  while (!stack. isEmpty()) {   int adjVertex = getAdjVertex(stack. peek());   if (adjVertex != -1) {    arrayOfVertex[adjVertex]. setVisited(true);    System. out. print(      arrayOfVertex[adjVertex]. getName() +    );    stack. push(adjVertex);   } else {    stack. pop();   }  } }12345678private int getAdjVertex(int vertex) {for (int adj=0; adj&lt;numOfVertices; adj++) {  if (matrixOfAdjVertex[vertex][adj] ==1 &amp;&amp;    arrayOfVertex[adj]. isVisited() ==false)    return adj; //return first adjacent vertex  }  return -1; //not vertices found}Test case 123456789101112131415161718192021222324252627282930313233@Test public void test_dfs() {  String city1 = Berlin ; String city2 = Leipzig ;  String city3 = Dresden ; String city4 = Nürnberg ;  String city5 = Hannover ; String city6 = Rostock ;  String city7 = Dortmund ; String city8 = Frankfurt ;  String city9 = Stuttgart ; String city10 = München ;  String city11 = Magdeburg ; String city12 = Bremen ;  graph. addVertex(new Vertex(city1));  graph. addVertex(new Vertex(city2));  graph. addVertex(new Vertex(city3));  graph. addVertex(new Vertex(city4));  graph. addVertex(new Vertex(city5));  graph. addVertex(new Vertex(city6));  graph. addVertex(new Vertex(city7));  graph. addVertex(new Vertex(city8));  graph. addVertex(new Vertex(city9));  graph. addVertex(new Vertex(city10));  graph. addVertex(new Vertex(city11));  graph. addVertex(new Vertex(city12));  graph. addEdge(city1, city2);  graph. addEdge(city2, city3);  graph. addEdge(city3, city4);  graph. addEdge(city4, city10);  graph. addEdge(city11, city5);  graph. addEdge(city5, city7);  graph. addEdge(city7, city8);  graph. addEdge(city8, city9);  graph. addEdge(city1, city6);  graph. addEdge(city1, city11);  graph. addEdge(city5, city12);  graph. dfs(city1); }Here, the output: 1Berlin Leipzig Dresden Nürnberg München Rostock Magdeburg Hannover Dortmund Frankfurt Stuttgart BremenWe can change the entry city and see different traversing paths 1Hannover Dortmund Frankfurt Stuttgart Magdeburg Berlin Leipzig Dresden Nürnberg München Rostock Bremen You can see as well the Breadth-First Search (BFS) algorithm by using an Adjacency List based on a LinkedList data structure in the following link "
    }, {
    "id": 24,
    "url": "http://localhost:4000/tree-data-structure-binary-search-tree/",
    "title": "Tree data structure: Binary Search Tree",
    "body": "2020/05/12 - Tree data structures are non-linear data structures, and they allow us to implement algorithms much faster than when using linear data structures. Tree: A tree is a data structure that consists of nodes connected by edges. Binary tree: A Binary tree can have two children: a left node and a right node. Every Node contains two elements: a key used to identify the data stored by the Node and a value that is the data contained in the Node. The following figure shows the binary tree terminology.  Binary search tree: The most common type of Binary tree is the Binary search tree, which has two main characteristics:  The value of the left Node must be lesser than the value of its parent.  The value of the right Node must be greater than or equal to the value of its parent. Moreover, you can search in a tree data structure quickly, as you can with an ordered array, and you can also insert and delete items quickly, as you can with a linked list. It takes a maximum of log2(N) attempts to find a value. As the collection of nodes gets large, the binary search tree becomes faster over a linear search which takes up to (N) comparisons. Tree data structure: Use Case:: The Global Trade Item Number (GTIN) can be used by a company to uniquely identify all of its trade items. The GTIN can be used to identify types of products that are produced by different manufacturers. A Webshop wants to retrieve information about GTINs efficiently by using a binary search algorithm. Solution: We create a Product Class which will be the data contained in a Node. 1234567public class Product { Integer productId; String name; Double price; String manufacturerName; . . . We create a NodeP Class to store a list of Products. Moreover, this Class allows us to have two NodeP attributes to hold the left and right nodes. 123456789101112public class NodeP { private String gtin; private List&lt;Product&gt; data; private NodeP left; private NodeP right; public NodeP(String gtin, List&lt;Product&gt; data) {  this. gtin = gtin;  this. data = data; }}We create a new abstract data type called TreeP to define the behavior of our Binary Search Tree, which includes a NodeP root variable for the first element to be inserted. We need to implement an insert method, where every time a new GTIN is inserted, it compares the current GTIN versus the new GTIN. We store the new GTIN on the left or the right Node, depending on the result. In this way, the insert method maintains an ordered binary search tree. A Test case to verify our assumptions: 12345@Testpublic void when_rootNull_inserNode() { tree. insert( 04007801321224 , new ArrayList&lt;&gt;(Arrays. asList(product1))); assertTrue(tree. getRoot() != null);}And here the implementation for the insert method: 1234567891011121314151617181920212223242526272829303132333435public class TreeP { private NodeP root; public void insert(String gtin, List&lt;Product&gt; data) {  NodeP newNode = new NodeP(gtin, data);  if (root == null)   root = newNode;  else {   NodeP current = root;   NodeP parent;   while (true) {    parent = current;    if (gtin. compareTo(current. getGtin()) &lt; 0) {     current = current. getLeft();     if (current == null) {      parent. setLeft(newNode);      return;     }    } else if (gtin. compareTo(current. getGtin()) &gt; 0) {     current = current. getRight();     if (current == null) {      parent. setRight(newNode);      return;     }    } else     current. setData(data);     return; //already exists   }  }  return; }}Create a Test case for a find method: 12345678910111213141516171819@Testpublic void test_findNode() { tree. insert( 04000345706564 ,  new ArrayList&lt;&gt;(Arrays. asList(product1))); tree. insert( 07611400983416 ,   new ArrayList&lt;&gt;(Arrays. asList(product2))); tree. insert( 07611400989104 ,   new ArrayList&lt;&gt;(Arrays. asList(product3, product4))); tree. insert( 07611400989111 ,  new ArrayList&lt;&gt;(Arrays. asList(product5))); tree. insert( 07611400990292 ,  new ArrayList&lt;&gt;(Arrays. asList(product6, product7, product8))); assertEquals(null, tree. find( 07611400983324 )); tree. insert( 07611400983324 ,  new ArrayList&lt;&gt;(Arrays. asList(product9))); assertTrue(tree. find( 07611400983324 ) != null); assertEquals( 07611400983324 ,   tree. find( 07611400983324 ). getGtin());}And here is the implementation that shows a find method (the gtin parameter is our key), which iterates through all nodes until a GTIN is found. This algorithm reduces the search space to N/2 because the binary search tree is always ordered. 1234567891011121314151617public NodeP find(String gtin) { NodeP current = root; if (current == null)  return null; while (!current. getGtin(). equals(gtin)) {  if (gtin. compareTo(current. getGtin()) &lt; 0) {   current = current. getLeft();  } else {   current = current. getRight();  }  if (current == null) //not found in children   return null; } return current;}This Binary Search Tree works well when the data is inserted in random order. Therefore, when the values to be inserted are already ordered, a binary tree becomes unbalanced. With an unbalanced tree, we can not find data quickly. One approach to solving unbalanced trees is the red-black tree technique, which is a binary search tree with some special features. Assuming that we already have a balanced tree, the following algorithm shows us how fast in terms of comparisons could be a binary search tree which depends on a number N of elements. For instance, in 1 billion products, to find a product by GTIN, the algorithm needs only 30 comparisons. See Big O Notation. 1234567@Testpublic void whenNelements_return_NroComparisons(){ assertTrue(treePerformance. comparisons(15) &lt;= 4); assertTrue(treePerformance. comparisons(31) &lt;= 5); assertTrue(treePerformance. comparisons(1000) &lt;=10); assertTrue(treePerformance. comparisons(1000000000) &lt;=30);}And here is our implementation. 12345678910111213141516public class TreePerformance { public static int comparisons(int N) {  int acumElements = 0;  int comparisons = 0;  for (int level = 0; level &lt;= N / 2; level++) {   int power = (int) Math. pow(2, level);   acumElements += power;   if (acumElements &gt;= N) {    comparisons = ++level;    break;   }  }  System. out. println( comparisons -&gt;   + comparisons);  return comparisons; }}Understanding the inner workings of common data structures and algorithms is a must for Java developers. Learn more "
    }, {
    "id": 25,
    "url": "http://localhost:4000/optimize-online-purchases/",
    "title": "Learning Test-Driven Development",
    "body": "2020/04/09 - Test-driven development (TDD) is a development approach that emphasizes writing a test before writing the necessary code and then refactoring the code to optimize it. Problem: Optimize a basket in online purchases means fill a basket with the most valuable goods under a given budget. Imagine that we have a budget of 4 US$ and we want to buy the most valuable snacks from the following table: But who decides if a product is more valuable than another one? Well, this depends on every business. It could be an estimation based on quantitative or qualitative analysis. For instance, for our solution, we choose a quantitative approach based on which product gives us more grams per every dollar invested. Optimize a basket in online purchases: Solution: To implement our algorithm to optimize a basket in online purchases, we use the Red-Green Refactor technique, which is the basis of test-drive-development (TDD). Firstly, in every assumption, we will write a test and see if it fails. Secondly, we write the code that implements only that test and sees if it succeed, then we can refactor the code to make it better. Finally, we continue with another assumption and repeat the previous steps until the algorithm is successfully implemented for all tests. To generalize the concept of “the most valuable product” we assign a value to every product. Our algorithm receives two parameters: an array 2-D which includes [product-id][price][value] and the budget. Assumption #1 – Given an array of products ordered by value, return the most valuable products We start defining a java test creating a new BasketOptimized class. For naming variables, you can read clean code. 12345678910111213141516171819202122232425262728public class BasketOptimizedTest { BasketOptimized basketOptimized; @Before public void setup() {  basketOptimized = new BasketOptimized(); } @Test public void productsOrderedByValue () {  double[][] myProducts = new double[][] {    {1, 0. 98, 230},    {2, 0. 98, 230},    {3, 0. 48, 75},    {4, 1. 29, 55},    {5, 1. 29, 47},    {6, 4. 86, 14},    {7, 1. 69, 12},  };  double[][] mostValueableProducts =    basketOptimized. fill(myProducts, 4);  assertEquals(590d,    Arrays. stream(mostValueableProducts).       mapToDouble(arr -&gt; arr[2]). sum(),0); }}The first time, it should fail because the fill method doesn’t exist. Then we need to create an easy implementation to pass the test: the sum of the values must be equal to 590 because this represents all selected products which its prices sum less or equal than 4. Now, we proceed to implement the fill method. 12345678910111213141516171819202122public class BasketOptimized { public double[][] fill(double[][] myProducts, double budget) {  int len = myProducts. length;  double[][] mostValueableProducts = new double[len][3];  double sum = 0;  for (int idx=0; idx &lt; len; idx++) {   sum = sum + myProducts[idx][1]; //price   if (sum &lt;= budget) {    mostValueableProducts[idx][0] =      myProducts[idx][0]; //id    mostValueableProducts[idx][1] =      myProducts[idx][1]; //price    mostValueableProducts[idx][2] =      myProducts[idx][2]; //value   }  }  return mostValueableProducts; }}Assumption #2 – Given an array of products not ordered by value, return the most valuable products In this case we pass a not ordered array, so we can see that our new test will fail. 123456789101112131415161718@Testpublic void productsNotOrderedByValue () { double[][] myProducts = new double[][]{   {1, 0. 98, 230},   {2, 1. 29, 47},   {3, 1. 69, 12},   {4, 1. 29, 55},   {5, 0. 98, 230},   {6, 4. 86, 14},   {7, 0. 48, 75} }; double[][] mostValueableProducts   = basketOptimized. fill(myProducts, 4); assertEquals(590d, Arrays. stream(mostValueableProducts)  . mapToDouble(arr -&gt; arr[2]). sum(), 0);}We realize that we need to order the array by value because we want the most valuable products, so its time to refactor our algorithm. What we need to do is to sort our input array. 123456public double[][] fill(double[][] myProducts, double budget) { Arrays. sort(myProducts, Collections. reverseOrder(   Comparator. comparingDouble(a -&gt; a[2]))); int len = myProducts. length; double[][] mostValueableProducts = new double[len][3];Then we can see our two test cases were successful. Calculate combinations: Assumption #3 – Given an array of products, we need to obtain the most valuable products from all possible combinations of the products Imagine the following escenario: 123456789101112131415double[][] myProducts = new double[][] {        {1, 0. 98, 230},        {2, 0. 51, 30},        {3, 0. 49, 28},        {4, 1. 29, 55},        {5, 0. 98, 230},        {6, 4. 86, 14},        {7, 0. 48, 75},    };double[][] mostValueableProducts = basketOptimized    . fill(myProducts, 4);assertEquals(590d,   Arrays. stream(mostValueableProducts)    . mapToDouble(arr -&gt; arr[2]). sum(),0);The test is expecting a result of 590 which corresponds to the final price of 3,73US$ (0. 98+0. 98+0. 48+1. 29). Once the algorithm sort by value the input array, we have the following result: 1234567[1. 0, 0. 98, 230. 0][5. 0, 0. 98, 230. 0][7. 0, 0. 48, 75. 0][4. 0, 1. 29, 55. 0][2. 0, 0. 51, 30. 0][3. 0, 0. 49, 28. 0][6. 0, 4. 86, 14. 0]But here we realize the exists another combination of products which give us the most valuable products: 230+230+75+30+28 = 593 which corresponds to the final price of 3,44US$. Then we need to refactor our code to calculate all combinations (subsets) and return the most valuable products under a budget of 4 US$. The subsets can be represented by all the binary options from 0 to 7 (the array size). 12345670000 = {}0001 = { {1, 0. 98, 230} }0010 = { {2, 0. 51, 30} }0011 = { {1, 0. 98, 230}, {2, 0. 51, 30} }. . . We build a hashMap to store all combinations and the sum of its values. Finally, we return the first element of the hashMap ordered by value 123456789101112131415161718192021int len = myProducts. length;int numIterations = (int) Math. pow(2, myProducts. length);Map&lt;double[][], Double&gt; combinations = new HashMap&lt;&gt;();for (int idx=0; idx&lt;numIterations; idx++){ double[][] combx = new double[len][]; double sumPrice = 0; double sumValue = 0; int i = 0; for (int idx2=0; idx2&lt;len; idx2++) {  if ((idx &amp; (int) Math. pow(2, idx2)) == 0) {    combx[i++] = myProducts[idx2];    sumPrice = sumPrice + myProducts[idx2][1];    sumValue = sumValue + myProducts[idx2][2];  } } if (combx. length &gt; 0 &amp;&amp; sumPrice &lt;= budget) {   combinations. put(combx, Double. valueOf(sumValue)); }}You can see the complete solution explained in detail and all test cases in this link "
    }, {
    "id": 26,
    "url": "http://localhost:4000/given-positive-number-n-find-smallest-number-same-number-digits/",
    "title": "Given N, find the smallest number with the same number of digits",
    "body": "2019/06/29 - Write a method that, given an original number N, returns the smallest number with the same number of digits. For instance, given N=4751, the method returns 1000. Given N=100, the method should return 100. Given N=1, the method should return 0. Maybe the first idea comes to our minds could be to iterate from the given original number and decrease one by one, and in every iteration to check if every new number contains one digit less than the original number, if the answer is true, then the previous one is the smallest number. Define a test case to validate what your code will do: Our assumption based on a test case: 12345678910111213141516public class SmallestNumberTest { @Test public void test_right_smallest_values() {  assertTrue(NumberUtils. smallest(4751) == 1000);  assertTrue(NumberUtils. smallest(189) == 100);  assertTrue(NumberUtils. smallest(37) == 10);  assertTrue(NumberUtils. smallest(1) == 0); } @Test public void test_wrong_smallest_values() {  assertFalse(NumberUtils. smallest(8) == 1);  assertFalse(NumberUtils. smallest(2891) == 2000); }}Here, is the implementation code that works for positive numbers: 1234567891011121314151617public class NumberUtils { public static int smallest(int N) {  int smallestNumber = 0;  if (N &lt;= 1)   return smallestNumber;    int numberOfDigitsOriginalN = String. valueOf(N). length();  while (N &gt; 0) {   N--;   if (String. valueOf(N). length() ==     (numberOfDigitsOriginalN -1)) {    return ++N;   }  }  return smallestNumber; }}If we realize, the solution follows a common pattern: N = 3891 -&gt; smallest number = 1000 N = 189 -&gt; smallest number = 100 N = 37 -&gt; smallest number = 10 The smallest number is a power of 10, where the exponent is: (number of digits of the given N – 1) If we want to include negative numbers, we must consider the smallest number with the same number of digits and the same sign. We add our test case for negative numbers as well: 12345@Test public void test_right_smallest_values() { assertTrue(NumberUtils. smallest4(-1) == -9); assertTrue(NumberUtils. smallest4(-37) == -99);}Here, is the algorithm for positive and negative numbers: 12345678910111213public class NumberUtils { public static int smallest(int N) {  int numberOfDigits = (int) String. valueOf(Math. abs(N)). length();  if (N &gt;= 0) {   if (numberOfDigits == 1) {    return 0;   } else {    return (int) Math. pow(10, numberOfDigits - 1);   }  } else   return 1 - (int) Math. pow(10, numberOfDigits); }}The main idea in Analysis of Algorithms is always to improve the algorithm performance by reducing the number of steps and comparisons. The simpler and more intuitive an algorithm is, the more useful and efficient it will be. "
    }];

var idx = lunr(function () {
    this.ref('id')
    this.field('title')
    this.field('body')

    documents.forEach(function (doc) {
        this.add(doc)
    }, this)
});
function lunr_search(term) {
    document.getElementById('lunrsearchresults').innerHTML = '<ul></ul>';
    if(term) {
        document.getElementById('lunrsearchresults').innerHTML = "<p>Search results for '" + term + "'</p>" + document.getElementById('lunrsearchresults').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>No results found...</li>";
        }
    }
    return false;
}

function lunr_search(term) {
    $('#lunrsearchresults').show( 400 );
    $( "body" ).addClass( "modal-open" );
    
    document.getElementById('lunrsearchresults').innerHTML = '<div id="resultsmodal" class="modal fade show d-block"  tabindex="-1" role="dialog" aria-labelledby="resultsmodal"> <div class="modal-dialog shadow-lg" role="document"> <div class="modal-content"> <div class="modal-header" id="modtit"> <button type="button" class="close" id="btnx" data-dismiss="modal" aria-label="Close"> &times; </button> </div> <div class="modal-body"> <ul class="mb-0"> </ul>    </div> <div class="modal-footer"><button id="btnx" type="button" class="btn btn-danger btn-sm" data-dismiss="modal">Close</button></div></div> </div></div>';
    if(term) {
        document.getElementById('modtit').innerHTML = "<h5 class='modal-title'>Search results for '" + term + "'</h5>" + document.getElementById('modtit').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><small><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></small></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>Sorry, no results found. Close & try a different search!</li>";
        }
    }
    return false;
}
    
$(function() {
    $("#lunrsearchresults").on('click', '#btnx', function () {
        $('#lunrsearchresults').hide( 5 );
        $( "body" ).removeClass( "modal-open" );
    });
});